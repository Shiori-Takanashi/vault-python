---
title: Python_Foundation_
keyword:
created: 2025-08-02 15:08
modified: 2025-08-02 15:08
vault: technology
catergory: Language
language: Python
area: Foundation
identify:  
type: 
role: 
order: 
---

## 📍01章：名前空間とは何か

---

### 📝解説

Python における **名前空間** とは、識別子（変数名・関数名・クラス名など）を一意に管理する領域である。
コードベースが巨大化しても同名の識別子が衝突しないように分離・整理する仕組みであり、
スコープ（有効範囲）の実体そのものとして機能する。
名前解決は **LEGB ルール**（Local → Enclosing → Global → Built-in）の順で実行時に動的に行われる。
この探索順を理解することは、バグ回避や設計の明確化に直結する。

### 📝利用範囲と導入

単純なスコープ挙動を確認する最小例は次のとおり。

```python
x = "global"

def func():
    x = "local"
    print(x)  # → local

func()
```

### 📝主な名前空間の種別と役割

| 名前空間      | 代表的な内容                       |
| --------- | ---------------------------- |
| Local     | 関数・メソッド内部の変数や引数              |
| Enclosing | ネストされた関数の外側関数で定義された変数        |
| Global    | モジュールレベルの変数・関数               |
| Built-in  | `len()`, `print()` など組み込み識別子 |

### 📝名前空間と周辺概念

* `scope` – 名前空間の生存範囲を規定する概念
* `globals()` / `locals()` – 現在の名前空間を辞書で取得
* `__dict__` – クラスやオブジェクトの内部名前空間
* `import` – 別モジュールの名前空間を取り込む操作
* `nonlocal` / `global` – 外側スコープを明示的に操作する文法

### 📝設計上の利点と限界

**利点**

* 衝突回避：識別子が被っても独立して管理可能
* 管理性：モジュール単位で責務を分離しやすい
* 可視性制御：意図したスコープで変数の見え方を限定

**限界**

* Enclosing と Global の挙動を誤解しやすい
* グローバル変数の副作用を追跡しづらい
* 多層クロージャでは把握が困難になる場合がある

### 📝学習上のポイント

* **LEGB ルール**を暗記し、`globals()`・`locals()`で可視化して確認する。
* `nonlocal` と `global` は例外的操作であり、多用すると設計が破綻する。
* 大規模コードではモジュール・クラス単位で明示的に名前空間を分け、副作用を最小化する。

---

## 📍02章：LEGBルールによる名前解決の順序

---

### 📝解説

Pythonでは、**変数や関数名が参照される際に、どの名前空間を使うかを決定する探索順序**が存在する。これを **LEGBルール（Local → Enclosing → Global → Built-in）** と呼ぶ。これは、Pythonが動的にスコープを探索する際の厳格な順序であり、**同名の識別子が複数存在する場合でも、どれが優先されるかを一貫して判断できる**基盤となっている。

このルールを理解しないままコードを書くと、意図しない識別子が参照されたり、バグの温床になりやすい。関数のネスト構造、クロージャ、モジュール構造の中でこそ、この探索順序の知識が問われる。



### 📝LEGB ルールの構造

| 名前空間         | 対象               | 典型例                            |
|-  | - |-  |
| Local（L）     | 現在実行中の関数・メソッド内部  | 関数の引数や内部変数                     |
| Enclosing（E） | 外側関数（クロージャ）のスコープ | ネスト関数での外部変数参照                  |
| Global（G）    | モジュール全体のスコープ     | スクリプト先頭で定義した変数など               |
| Built-in（B）  | Python 組み込みの識別子  | `len()`, `sum()`, `print()` など |



### 📝探索の順序と挙動例

以下のコードで、`x` がどこから参照されるか確認できる：

```python
x = "global"

def outer():
    x = "enclosing"
    def inner():
        x = "local"
        print(x)
    inner()

outer()  # → local
```

この例では `inner()` 内での `x` は Local スコープに存在するため、それが優先される。Enclosing や Global には到達しない。



### 📝参照と代入の違い

LEGBは「参照時」に適用される。**代入は基本的にLocalスコープに行われる**ため、`global` や `nonlocal` を使わないと外部スコープの変数を書き換えることはできない。

```python
x = "global"

def func():
    x = "local"  # Globalを書き換えているわけではない
    print(x)

func()
print(x)  # → global
```



### 📝暗黙的なエラーの例

LEGBを理解せずにコードを書くと、次のような意図しないエラーが起こる：

```python
x = 10

def f():
    print(x)  # UnboundLocalError if x = x + 1 is added here
    x = x + 1

f()
```

このコードは `print(x)` の時点で `x` が Local スコープに存在しないのに、「この関数内で代入がある」と認識されるため `UnboundLocalError` が発生する。



### 📝学習上のポイント

* LEGBは「**参照**の順序」であって、「**代入**の順序」ではない。
* `nonlocal` や `global` を用いない限り、**外側スコープの変数を上書きすることはできない**。
* 関数のネスト、クロージャ、モジュール分割などでスコープが複雑化する場面では、**LEGBを意識した設計**が必要である。

---
