---
title: Python_Foundation_
keyword:
created: 2025-08-04 00:49
modified: 2025-08-04 00:49
vault: technology
catergory: Language
language: Python
area: Foundation
identify:  
type: 
role: 
order: 
---


## 📍01章：変数は名前

---

### 📝解説

Python における変数は、C 言語や Java のように「値を入れる箱」ではなく、\*\*オブジェクトに付けられた名前（ラベル）\*\*である。
`x ＝ 10` と書いたとき、実際には「整数オブジェクト 10 を生成（または再利用）し、その参照を名前 x に関連付ける」処理が行われる。
このため、1 つのオブジェクトに対して複数の名前を持たせることが可能であり、**名前とオブジェクトは分離して存在**する。

---

### 📝参照の共有と挙動

複数の名前が同じオブジェクトを参照していると、片方での変更がもう片方にも影響する。

```python
a ＝ [1, 2, 3]
b ＝ a
b.append(4)
print(a)  # [1, 2, 3, 4]
```

この例では `a` と `b` は同一のリストを参照しているため、`b` での変更が `a` にも反映される。

---

### 📝`id()` 関数による同一性確認

`id(obj)` は、オブジェクトを一意に識別する整数値を返す（CPython では多くの場合メモリアドレス）。

```python
print(id(a), id(b))  # 同じ値が出力される
print(a is b)        # True（同一オブジェクトを参照）
```

これにより、変数同士が同じオブジェクトを共有しているかを確認できる。

---

### 📝名前とオブジェクトの関係を理解する意義

**利点**

* メモリ効率の向上：不要な複製を避けられる
* 同じデータを複数箇所から扱える

**注意点**

* 可変オブジェクトの場合、意図しない共有がバグの原因になる
* 参照関係が複雑になると予期せぬ副作用が生じやすい

---

### 📝学習上のポイント

* 「変数は値を入れる箱」ではなく「オブジェクトへの名前」というモデルで理解する
* 可変オブジェクトを共有する場合は、**コピーを作るのか共有するのか**を明示的に判断する
* `is` や `id()` を使って、同一性と等価性の違いを確認できるようにする

この概念は、Python の参照モデル全体の土台であり、後の「代入と共有」「デフォルト引数の落とし穴」などを理解する前提となる。


---

## 📍02章：`id()` の意味

---

### 📝解説

`id(obj)` は、**そのオブジェクトが存在している間だけ一意**である整数を返す。
CPython では実質的に「オブジェクトのアドレス（`PyObject*` の値）」が返ることが多いが、**仕様は実装非依存**であり、他実装（PyPy など）ではアドレスとは限らない。
したがって、`id()` は**同一性（identity）の観測**に用いるべきで、アドレス計算・順序比較・保存値としての活用は不適切である。

---

### 📝基本的な性質

* **同一性の指標**：同じオブジェクトなら `id(a) ＝＝ id(b)`。
* **等価性とは無関係**：値が等しくても別オブジェクトなら `id` は異なる。
* **寿命限定の一意性**：オブジェクト破棄後は **id が再利用**され得る。
* **実装差あり**：CPython 以外では「アドレスである」とは限らない。

```python
a ＝ [1, 2, 3]
b ＝ a
c ＝ [1, 2, 3]

a is b              # True（同一性）
a ＝＝ c              # True（等価性）
id(a) ＝＝ id(b)      # True
id(a) ＝＝ id(c)      # False
```

---

### 📝`is` と `id()` の関係

* `a is b` は **同一オブジェクトか**を直接判定する。
* `id(a) ＝＝ id(b)` はその**別表現**にすぎない。
* 可読性・最適化の観点から、**コード中の判定は `is` を優先**し、`id()` はあくまで**観測・デバッグ**目的に留める。

```python
# 推奨
if x is None:
    ...

# デバッグ（観測）には OK
print(hex(id(x)))
```

---

### 📝「寿命内で一意」の具体例

破棄済み領域が**再割り当て**されると、**同じ `id` が別オブジェクトに付く**ことがある。

```python
import gc

def make():
    return object()

o1 ＝ make()
oid ＝ id(o1)
del o1
gc.collect()               # 破棄を促す
o2 ＝ make()
hex(oid), hex(id(o2))      # 同じになることがある（環境依存）
```

> 重要：この再利用性のため、`id()` の数値を**永続化して照合に使うのは危険**。

---

### 📝`id()` と生成タイミングの影響

* **新規生成**すれば `id` は通常変わる。
* **浅いコピー／深いコピー**で `id` がどう変化するかは、**同一性の観測**として有用。

```python
import copy

lst ＝ [[1], [2]]
shallow ＝ copy.copy(lst)        # 第一階層は新規（id が変わる）
deep    ＝ copy.deepcopy(lst)    # 再帰的に新規（すべて id が変わる）

id(lst) !＝ id(shallow)          # True
id(lst[0]) ＝＝ id(shallow[0])    # True（浅いコピーなので中身は共有）
id(lst[0]) ＝＝ id(deep[0])       # False（深いコピー）
```

---

### 📝CPython と他実装の違い（実装依存）

* **CPython**：`id()` ≒ **アドレス**。`hex(id(obj))` で読みやすい。
* **PyPy/Jython**：一意な**識別子**を返す実装もあり、アドレスとは限らない。
* いずれも「**寿命内一意**」以外の性質に**期待しない**こと。

---

### 📝観測の定石（デバッグの実務）

* **同一性の追跡**：入れ子構造のどの階層が共有されているかを `id()` で確認。
* **変更の影響範囲**：ミュータブルに対して操作前後の `id()` を比較し、
  「同じオブジェクトを**破壊的に更新**したのか」「**新しいオブジェクト**に置き換えたのか」を切り分ける。

```python
a ＝ [1, 2, 3]
aid ＝ id(a)
a.append(4)
id(a) ＝＝ aid     # True（破壊的更新）

a ＝ a + [5]
id(a) ＝＝ aid     # False（新オブジェクトに置換）
```

---

### 📝やってはいけないこと

* `id()` の大小比較や差分に**意味づけ**する（連続・順序は**無保証**）。
* `id()` を**データベースのキー**等に保存して後で同一性判断に使う。
* 文字列や整数の\*\*最適化（インターン/小整数キャッシュ）\*\*に依存して、`is` の結果を期待する。
  （それは実装依存。値比較には常に `＝＝` を使う。）

---

### 📝補助的テクニック

* 表示を見やすくする：`hex(id(obj))`
* 多数比較の可視化：内包表記で `(value, hex(id(obj)))` を並べて観測
* テストでは `unittest.TestCase.assertIs(a, b)` を使い、`id()` の数値比較を避ける

```python
# 例：dict の値オブジェクトが共有されていないかを点検
d ＝ {"x": [1], "y": [1]}
for k, v in d.items():
    print(k, hex(id(v)))
```

---

### 📝周辺知識との接点

* **同一性 vs 等価性**：`is` は同一性、`＝＝` は値。
* **イミュータブル最適化**：小整数や一部文字列は再利用され得る（`is` 判定が**たまたま**真になることがある）。
* **弱参照（`weakref`）**：オブジェクト寿命の監視に使えるが、`id()` の永続化代替にはならない。


---

## 📍03章：`is` ・ `＝＝`

---

### 📝解説

Python の比較には、\*\*同一性（identity）\*\*を判定する `is` と、**等価性（equality）**を判定する `＝＝` がある。
`is` は「**同じオブジェクトを指しているか**」、`＝＝` は「**値（内容）が等しいか**」を調べる。
`＝＝` の判定は多くの型で `__eq__` 実装に委ねられ、必要なら要素をたどる深い比較が行われる。一方 `is` は**参照の一致**を見るだけで高速かつ浅い。

---

### 📝基本モデルとリッチ比較

* `a is b`
  オブジェクト同一性の判定。内部的には `id(a) ＝＝ id(b)` と同義。
* `a ＝＝ b`
  等価性の判定。`type(a).__eq__(a, b)` が呼ばれる（片側が `NotImplemented` を返すと、もう片側の `__eq__` を試し、それでもだめなら `False`）。
* 既定の `object.__eq__` は**同一性ベース**（実質 `is` と同じ）なので、`__eq__` を実装しない独自クラスは `＝＝` でも同一性比較になる。

```python
a ＝ [1, 2, 3]
b ＝ [1, 2, 3]
c ＝ a

a ＝＝ b   # True（値が同じ）
a is b   # False（別オブジェクト）
a is c   # True（同一オブジェクト）
```

---

### 📝`None`・シングルトンとの比較（ベストプラクティス）

* `None` 判定は **`is` / `is not`** を使う。
* そのほかのシングルトン：`True`, `False`, `Ellipsis`, `NotImplemented` も `is` で判定してよい。
* ただし `x is True` や `x is False` は**可読性が低い**ため避け、`if x:` / `if not x:` を使う。

```python
x ＝ None
if x is None:
    ...
```

---

### 📝イミュータブル最適化に伴う注意（`is` の偶然の True）

* 小整数（例：`-5..256`）や一部の短い/識別子風文字列は**再利用**（インターン）されることがある。
* そのため `a is b` が **たまたま True** になることがあるが、**保証ではない**。
* **値比較には常に `＝＝`** を使い、`is` は同一性確認専用にする。

```python
256 is 256   # True になりやすい（実装依存）
257 is 257   # False になりやすい
```

---

### 📝コンテナの等価性と計算量

* **リスト/タプル**：要素を左から順に比較（短絡評価）。深いネストも再帰的に `＝＝` で比較。
* **辞書**：キー・値の組が同じなら順序に関係なく等しい。
* **集合**：要素集合が等しければ順序無関係で等しい。
* これらは要素数やネストに比例して**コストが増える**。`is` は O(1) だが意味が違うため代用不可。

```python
{"a": 1, "b": 2} ＝＝ {"b": 2, "a": 1}  # True
```

---

### 📝数値系の特例：NaN・浮動小数の比較

* `float('nan') ＝＝ float('nan')` は **False**（NaN は自分自身とも等しくない）。
* 値の有無を確認するには `math.isnan(x)` を使う。
* 浮動小数の誤差を考慮する比較には `math.isclose(a, b)` を用いる（`＝＝` の代わり）。

```python
import math
x ＝ float('nan')
x ＝＝ x            # False
math.isnan(x)     # True
math.isclose(0.1 + 0.2, 0.3)  # True になりやすい
```

---

### 📝配列/数値ライブラリの注意（NumPy 等）

* `numpy.array` 同士の `＝＝` は**要素ごとの配列**を返す。`if arr1 ＝＝ arr2:` はエラーになる。
* **同値判定**には `numpy.array_equal(a, b)`、近似なら `numpy.allclose(a, b)` を使う。
* `is` は**同じ配列オブジェクトか**の判定にのみ使える。

```python
import numpy as np
a ＝ np.array([1,2,3]); b ＝ np.array([1,2,3]); c ＝ a
(a ＝＝ b).all()         # True
a is b                 # False
a is c                 # True
```

---

### 📝カスタムクラスでの設計指針

* **値オブジェクト**として扱いたい場合は `__eq__` を実装し、必要に応じて `__hash__` も整合的に定義（不変に限る）。
* **同一性でのみ比較**したい場合は `__eq__` を実装しない（既定の同一性比較のまま）。
* `dataclasses.dataclass` は既定で `__eq__` を自動生成（フィールド値の等価性）。必要に応じて `eq＝False` を指定。

```python
from dataclasses import dataclass
@dataclass
class Point:
    x: int; y: int

Point(1,2) ＝＝ Point(1,2)  # True（値比較）
```

---

### 📝センチネル（番兵）と `is`

* 関数引数の**未指定**や特殊状態を区別するため、**一意なオブジェクト**をセンチネルにする。
* 比較は `is` を使う（同じ実体かどうかを見るため）。

```python
_sentinel ＝ object()

def f(x＝_sentinel):
    if x is _sentinel:
        # 未指定
        ...
```

---

### 📝テストでの比較 API

* **同一性**：`unittest.TestCase.assertIs(a, b)` / `assertIsNot(a, b)`
* **等価性**：`assertEqual(a, b)` / `assertNotEqual(a, b)`
* `None` 判定：`assertIsNone(x)` / `assertIsNotNone(x)`

---

### 📝デバッグの実務 TIPS

* 参照の追跡には `a is b` と `hex(id(a))` の併用が便利。
* 破壊的操作か再代入かを区別するには、**操作前後で `id()` が変わるか**を確認する。

```python
lst ＝ [1,2,3]
i0 ＝ id(lst)
lst.append(4)       # 破壊的更新
id(lst) ＝＝ i0       # True

lst ＝ lst + [5]     # 新規オブジェクト（非破壊的に見える置換）
id(lst) ＝＝ i0       # False
```

---

### 📝実務指針（まとめ）

* **`is` は同一性**（`None`・シングルトン・センチネル）に限定。
* **値の比較は `＝＝`**。数値誤差・NaN・配列など**型固有の比較関数**を用いる。
* イミュータブル最適化（小整数/文字列インターン）に**依存しない**。
* パフォーマンス目的で `is` を選ぶのは誤り。**意味論**を優先する。

---

## 📍04章：イミュータブル最適化

---

### 📝解説

Python では整数・文字列・タプルなどの**イミュータブル（不変）型**に対し、同じ値を何度も作らず**再利用**する最適化が行われることがある。代表例が**小整数キャッシュ**と**文字列インターン**である。
ただし、これらは**実装依存・状況依存**であり、「`is` がたまたま `True` になる」ことはあっても**仕様として保証されない**。ゆえに、**値比較は `＝＝`、同一性判定のみ `is`** という原則が重要になる。

---

### 📝代表的な最適化の種類

| 種別             | 典型対象                                                  | 目的/概要                 |
| -------------- | ----------------------------------------------------- | --------------------- |
| 小整数キャッシュ       | `-5`〜`256` 前後の整数                                      | 頻出する整数オブジェクトを再利用      |
| 文字列インターン       | 識別子風/短いリテラル                                           | 同値な文字列の再生成コスト削減       |
| 定数畳み込み（コンパイル時） | `"a"+"b"` → `"ab"` など                                 | 定数式を事前計算して 1 つの定数に集約  |
| シングルトン         | `None`, `True`, `False`, `Ellipsis`, `NotImplemented` | 常に同一オブジェクト            |
| 空の再利用（実装依存）    | `()`（空タプル）など                                          | 空オブジェクトを共有して節約することがある |

> 注：範囲・条件・動作は**実装やバージョンで変化**し得る。

---

### 📝整数の最適化（小整数キャッシュ）

CPython では一般に小さな整数は**事前生成して再利用**される。

```python
a ＝ 256
b ＝ 256
a is b  # 多くの実行環境で True（小整数キャッシュ）
```

一方、範囲外の整数は通常は新規生成される。

```python
x ＝ 257
y ＝ 257
x is y  # 多くの場合 False（別オブジェクト）
```

**ポイント**

* キャッシュ範囲は実装依存（典型は `-5..256` だが**保証ではない**）。
* REPL とスクリプト、同一コードオブジェクト内外で結果が揺れることがある。
* **値比較に `is` を使わない**（`＝＝` を使う）。

---

### 📝文字列の最適化（インターン）

短い文字列や**識別子として有効な形**の文字列は**インターン**され、同じ内容なら同一オブジェクトが再利用されることがある。

```python
s1 ＝ "hello"
s2 ＝ "hello"
s1 is s2  # True になることが多い
```

ただし、**実行時生成**の文字列は別物になることが多い。

```python
s3 ＝ "".join(["he", "llo"])
s1 is s3  # 通常は False（別オブジェクト）
```

コンパイル時に定数と判断されると**定数畳み込み**が行われる。

```python
t1 ＝ "py" "thon"     # リテラル連結 → "python"
t2 ＝ "py" + "thon"   # これもコンパイル時に畳み込まれる
t1 is t2             # True になり得る（同じ定数扱い）
```

**明示的インターン**

大量の重複キーなどで**比較を高速化・メモリ節約**したい場合は `sys.intern()` を使う。

```python
import sys
k1 ＝ sys.intern("very_long_key")
k2 ＝ sys.intern("very_" + "long_key")
k1 is k2  # True（同一オブジェクトを共有）
```

---

### 📝その他のイミュータブル再利用

* **シングルトン**：`None`, `True`, `False`, `Ellipsis`, `NotImplemented` は常に同一。
  → これらの判定には `is` を使ってよい。
* **空オブジェクト**：空タプル `()` はしばしば再利用される（実装依存）。
  ただし、**一般化して `is` を使う根拠にはならない**。

---

### 📝`is` を使った比較が危険になる理由

* **実装/バージョン差**で結果が変わる。
* **コード位置**（同一関数内か、別関数か）や**生成タイミング**（コンパイル時/実行時）で最適化の有無が変わる。
* REPL の都合（セル単位最適化など）で**再現性が低い**。

**悪い例**

```python
# 「インターンされる前提」で is を使うのは NG
def is_ok(s):
    return s is "OK"   # 実装や状況で False にもなり得る
```

**良い例**

```python
def is_ok(s):
    return s ＝＝ "OK"   # 値比較で安定
```

---

### 📝実務での活用例

* **大量の文字列キー**（ログ種別・イベント名・トークン種別など）を辞書や集合で扱う場合、
  `sys.intern()` で明示的にインターンすると、比較が**ポインタ比較**になりコスト削減が見込める。
* ただし、**闇雲なインターンは逆効果**（メモリ固定化）になりうるため、**ホットパスのキーに限定**する。

---

### 📝確認実験（ブレやすさを体感）

```python
def f():
    a ＝ 256; b ＝ 256
    print("small int:", a is b)   # True になりやすい

    x ＝ 257; y ＝ 257
    print("large int:", x is y)   # False になりやすい

    s1 ＝ "spam"
    s2 ＝ "sp" + "am"              # 定数畳み込みで True になり得る
    print("literal str:", s1 is s2)

    part ＝ "sp"; s3 ＝ part + "am" # 実行時生成で False になりやすい
    print("runtime str:", s1 is s3)

    import sys
    s4 ＝ sys.intern(part + "am")
    print("interned str:", s1 is s4)  # True
f()
```

---

### 📝学習上のポイント

* 値比較は `＝＝`、同一性は `is`・`None` などのシングルトンに限定。
* 小整数・文字列の**最適化に依存しない**設計を徹底する。
* 文字列キーが多いホットパスでは`sys.intern()` を計測しつつ限定的に適用する。
* 期待挙動が揺れるときは、`id()` で同一性を観測し、原因を切り分ける。

このように、イミュータブル最適化は**性能上の恩恵**がある一方で、**同一性への安易な依存**はバグの温床になる。原則を守り、必要に応じて明示的にコントロールすることが重要である。

---