---
title: Python_Foundation_
keyword:
created: 2025-08-03 03:24
modified: 2025-08-03 03:24
vault: technology
catergory: Language
language: Python
area: Foundation
identify:  
type: 
role: 
order: 
---

# 📢Python_Reference_Lesson_Index

---

## 📍 第01部：参照の基礎



### 📝第01章：変数は名前

* 「箱」モデルの否定
* 名前とオブジェクトの分離
* `id()` 関数の使用



### 📝第02章：`id()` の意味

* `id(obj)` は何を返すのか
* メモリアドレスとの関係
* 参照の可視化手段としての利用



### 📝第03章：`is` ・`＝＝`

* 等価性 vs 同一性
* `is` を使うべきケース
* `None` との比較での使用例



### 📝第04章：イミュータブル最適化

* 整数・文字列などのインターン
* 小さい整数の再利用
* 暗黙の最適化と副作用の危険性



### 📝第05章：代入と共有

* `a ＝ b` による共有
* 書き換えが双方に影響する場合
* `a[:] ＝ ...` との違い



### 📝第06章：デフォルト引数

* `def f(x＝[])` の落とし穴
* デフォルト引数が共有される理由
* 対処法： `None` + 初期化



### 📝第07章：引数と参照

* 実引数と仮引数の実体
* ミュータブル型を渡したときの挙動
* 関数内での再代入は外部に影響しない理由



### 📝第08章：破壊的操作の影響

* `.append()` などの操作
* 外部変数の意図しない変更
* 予防策と設計上の配慮



### 📝第09章：浅いコピー

* オブジェクトの第一階層のみをコピー
* ネスト構造がある場合の危険性
* 参照が混在するケースの例



### 📝第10章：深いコピー

* 入れ子構造全体を複製
* 循環参照の扱い
* `memo` による再訪問制御

---

## 📍 第02部：典型バグとその背景

---

### 📝第11章：`[[]] * 3` の罠

* 同一リストの複製による共有
* インデックスでの変更が全体に波及
* 正しいリスト生成法との比較



### 📝第12章：辞書と参照

* 値の共有によるバグの発生
* `dict.copy()` の挙動
* 変更の影響範囲を限定する方法



### 📝第13章：多重構造

* ネストされたリスト・辞書の影響範囲
* 表層と深層の切り分け
* 再帰的な確認と保守性



### 📝第14章：クラス属性

* クラス変数とインスタンス変数の違い
* ミュータブル型の落とし穴
* `__init__` での個別生成の必要性



### 📝第15章：初期値の共有

* `self.items ＝ []` を避けるべき位置
* クラス属性で初期化した場合の副作用
* 意図しない全インスタンス共有の事例



### 📝第16章：操作の副作用

* `.append()` vs `+`
* `.update()` vs `{**dict1, **dict2}`
* 関数の副作用を設計に明示する意義



### 📝第17章：イテレータ状態

* ジェネレータはオブジェクトである
* 状態の保存と共有
* `for` 文で使いまわすことのリスク



### 📝第18章：`None` による切断

* `x ＝ None` による参照解除
* `is None` を使うべき理由
* 実体がないことを表す安全な方法

---

## 📍 第03部：設計とテスト

---

### 📝第19章：参照と設計方針

* 値渡しスタイル vs 参照渡しスタイル
* 読みやすさと意図の明示
* 状態管理を明確化する方法



### 📝第20章：副作用の明示

* ミュータブルな引数に影響を与える場合
* 関数仕様書・docstringでの注意喚起
* テスト容易性との関係



### 📝第21章：`assertIs` の活用

* unittestでの参照の確認
* `is` を使った厳密比較
* 参照バグの早期検知



### 📝第22章：動的参照操作

* 名前空間の辞書としての活用
* 実用上のリスクと可読性
* Pythonic とは言い難い構成例



### 📝第23章：参照を断つ設計

* 疎結合・副作用ゼロ設計
* 関数型スタイルの活用
* テスト性・保守性の向上

---

## 📍 第04部：メモリと共有構造

---

### 📝第24章：メモリリーク

* 不要オブジェクトへの参照の放置
* キャッシュ・クロージャが原因の例
* 遅延評価との関係性



### 📝第25章：`del` の効果

* 名前空間からの削除
* `gc` による最終的な回収
* 参照カウントが0になるまで残る



### 📝第26章：`getrefcount()` の実験

* 実験的に参照数を確認する方法
* `+1` されている理由
* 本質的な確認には `gc` が必要



### 📝第27章：`gc` と循環参照

* 参照カウントでは解決できないケース
* `gc.collect()` による手動回収
* `__del__()` の干渉と副作用



### 📝第28章：グローバル共有の危険

* 参照の共有による不具合
* `global` の使用を避ける理由
* 安全な共有設計：関数間依存の抑制



### 📝第29章：スレッドと参照

* 複数スレッドによる同一参照の競合
* `threading.Lock()` などの制御
* 不変設計の導入による回避



### 📝第30章：キャッシュ設計

* オブジェクトの再利用戦略
* `lru_cache` / `dict` によるキャッシュ
* 再生成コストとのトレードオフ

---

## 📍 第05部：参照の特殊構造

---

### 📝第31章：クロージャと変数束縛

* 関数がスコープ外の変数を記憶する仕組み
* `def outer(): def inner():` のような構造
* 参照として残る名前とそのリスク



### 📝第32章：`nonlocal` の役割と設計

* `nonlocal` による外側変数への代入
* クロージャ内部での状態更新パターン
* 再代入の明示によるバグ予防



### 📝第33章：lambda の参照落とし穴

* `lambda` 式が評価時に変数を参照する理由
* `for` ループでの `lambda` 誤用パターン
* リスト内包と同時使用時の注意点



### 📝第34章：デフォルト引数による参照固定

* `lambda x＝i:` のような固定値の技法
* 評価タイミングの違いを利用した工夫
* 暗黙の束縛を明示する設計方針



### 📝第35章：型ヒントによる意図の明示

* `list[int]` vs `tuple[int, ...]` の選択
* ミュータブルとイミュータブルの設計指針
* `dict[str, Any]` の具体的使用事例



### 📝第36章：`Final` と不変設計

* `from typing import Final` の基本
* 共有参照での意図しない書き換え防止
* `Final` による設計上の契約の明示

---
