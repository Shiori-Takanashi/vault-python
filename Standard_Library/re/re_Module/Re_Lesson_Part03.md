---
作成日時: 2025-07-27 01:55
変更日時: 日曜日 27日 7月 2025 01:55:29
---

## 📍第3部：特殊なシーケンス

---

## 21章：`\d`, `\D`（数字と非数字）

---

### 解説

`\d` は**数字（digit）に一致するメタシーケンス**であり、具体的には `0〜9` の1桁に相当する。対して `\D` はその否定であり、**数字以外の任意の1文字**に一致する。

これらは `[0-9]` や `[^0-9]` の簡略記法と見ることができるが、Pythonでは `\d` の意味が**Unicode環境下で拡張される可能性**がある点に注意が必要である（例：全角数字も含まれる場合がある）。ASCIIのみに限定したい場合は `re.ASCII` フラグを併用する。

---

### 基本使用例①：数字の抽出

```python
import re

text = "ID=1234"
m = re.search(r"\d+", text)
print(m.group())  # → 1234
```

→ `\d+` により、1文字以上の連続した数字にマッチ。

---

### 基本使用例②：非数字の検出

```python
text = "abc123"
m = re.search(r"\D+", text)
print(m.group())  # → abc
```

→ `\D+` によって、連続する非数字（ここではアルファベット）を抽出。

---

### 応用例①：電話番号の抽出

```python
text = "電話: 03-1234-5678"
pattern = r"\d{2,4}-\d{2,4}-\d{3,4}"
print(re.findall(pattern, text))  # → ['03-1234-5678']
```

→ `\d{m,n}` を組み合わせることで、**桁数が柔軟な数値パターン**を正確に表現可能。

---

### 応用例②：英数字混在文字列の先頭数値検出

```python
text = "2023年度報告"
m = re.match(r"\d+", text)
print(m.group())  # → 2023
```

→ 文頭に数字がある場合にのみ抽出される（`re.match()` 使用により先頭限定）。

---

### `\d` と `[0-9]` の違い（Unicode対応）

```python
text = "１２３４"  # 全角数字
print(bool(re.fullmatch(r"\d+", text)))        # → True（デフォルトではマッチ）
print(bool(re.fullmatch(r"\d+", text, re.ASCII)))  # → False（ASCII限定）
```

→ Python 3ではデフォルトで `\d` は Unicode 数字を含むが、`re.ASCII` によって ASCII の `0-9` に制限される。

---

### 否定パターン `\D` の実用性

* ユーザーIDやコードの中に**数字以外の異常データが混入していないか**をチェック
* 入力が完全に数字で構成されているかどうかの検査（例：`^\d+$`）
* 数字の前後に**非数字が現れる位置を分離**（トークン化処理）

---

### 注意点

* `\d` は「1桁」の数字のみを対象とする。複数桁にマッチさせるには `\d+` や `\d{4}` のように繰り返し指定が必要
* `\D` は否定を意味するが、「数字以外すべて」に反応するため、**空白・記号・漢字**なども含まれる
* 正確に制限したい場合は `[0-9]` を明示的に使うことで明瞭性が増す

---

### 実務での用途

* **ID・パスワード・コード類の数値チェック**
* **フォーム入力のバリデーション（年・月・日など）**
* **ログ中の番号・ポート番号・PID抽出**
* **ファイル名・URL中の数字列の取得**
* **全角数字との整合性を取るための前処理（正規化）**

`\d` / `\D` は、文字列中の数字・非数字を正確に識別し、**構文の検証・抽出・分類に広く応用される汎用的構文**である。

---

## 22章：`\w`, `\W`（単語構成文字と非単語）

---

### 解説

`\w` は、\*\*単語を構成する文字（word character）\*\*にマッチするメタシーケンスであり、デフォルトでは以下の文字に一致する：

* アルファベット（`a-z`, `A-Z`）
* 数字（`0-9`）
* アンダースコア（`_`）

つまり、`[a-zA-Z0-9_]` の簡略表記である。対して `\W` はその否定で、**単語構成文字以外の1文字**に一致する（空白、記号、全角など）。

Pythonではデフォルトで `\w` は Unicode にも対応しているため、**日本語や他言語の文字にも一致する場合がある**。挙動をASCIIに限定したいときは `re.ASCII` フラグを使う。

---

### 基本使用例①：英数字とアンダースコアにマッチ

```python
import re

text = "name_123"
m = re.search(r"\w+", text)
print(m.group())  # → name_123
```

→ 単語に相当する連続した文字列をまとめて抽出可能。

---

### 基本使用例②：単語以外の記号や空白の抽出

```python
text = "value = 42;"
matches = re.findall(r"\W", text)
print(matches)  # → [' ', '=', ' ', ';']
```

→ 空白や記号など、**構文的な区切り記号**を抽出できる。

---

### 応用例①：ユーザー名や変数名の妥当性チェック

```python
username = "user_01"
if re.fullmatch(r"\w{4,12}", username):
    print("有効なユーザー名")
```

→ 4〜12文字の英数字＋アンダースコアのみを許可。**Python変数名の検査にも近い**。

---

### 応用例②：トークンの切り出しと分類

```python
text = "The price is $42.50!"
words = re.findall(r"\w+", text)
print(words)  # → ['The', 'price', 'is', '42', '50']
```

→ `.` や `$` などは無視され、単語と数値のみが抽出される。自然言語処理の\*\*前処理（トークン化）\*\*にも使われるパターン。

---

### 応用例③：ASCII限定動作との比較

```python
text = "変数名_123"
print(bool(re.fullmatch(r"\w+", text)))  # → True（Unicode）
print(bool(re.fullmatch(r"\w+", text, re.ASCII)))  # → False（ASCII限定）
```

→ 日本語（Unicode文字）も単語文字と見なされるが、`re.ASCII` によって英数字と `_` のみに制限可能。

---

### よく使うパターン例

| パターン      | 意味           | 用途例               |
| --------- | ------------ | ----------------- |
| `\w+`     | 単語1つ以上       | 単語抽出、識別子抽出        |
| `^\w+$`   | 行全体が単語文字のみ   | ユーザー名・変数名のバリデーション |
| `\W+`     | 非単語1文字以上     | 区切り文字、記号検出        |
| `\b\w+\b` | 単語単位の境界付きマッチ | 文脈に依存しない単語の検出     |

---

### 注意点

* `\w` は単語**全体**ではなく**1文字単位**に適用されるので、連続した文字列を扱う場合は `\w+` を使う
* `\W` にマッチするのは空白や記号だけでなく、全角記号や漢字なども含む
* `\w` の範囲は実行環境・Pythonバージョン・フラグ指定により挙動が変わる場合がある

---

### 実務での用途

* **ユーザー名・パスワード・変数名などの形式制限**
* **単語単位でのトークン化や検索**
* **構文解析における記号・演算子の分離**
* **入力値の構成文字チェック**
* **コードやログファイルの識別子抽出**

`\w` / `\W` は、**文字種による分類と検出を簡潔に記述できる便利な構文**であり、データ整形・構文検査・自然言語処理など幅広い応用で用いられる。

---

## 23章：`\s`, `\S`（空白と非空白）

---

### 解説

`\s` は空白文字（space character）にマッチするメタシーケンスであり、スペース (` `` `) に加え、タブ (`\t`)、改行 (`\n`)、復帰 (`\r`)、垂直タブ (`\v`)、フォームフィード (`\f`) など、**あらゆる種類の空白文字1文字に一致**する。

対になる `\S` は、**空白以外の任意の1文字**にマッチする。つまり、「文字」「記号」「数字」など、空白でないすべてが対象となる。

`\s` / `\S` は、入力の**整形・トリム・構造検出・空白区切りの分離**などに広く使われる。

---

### 基本使用例①：空白の抽出

```python
import re

text = "a \t b\nc"
spaces = re.findall(r"\s", text)
print(spaces)  # → [' ', '\t', '\n']
```

→ 空白・タブ・改行がすべて対象となり、空白文字がどこにあるかを把握できる。

---

### 基本使用例②：空白以外の文字列抽出

```python
text = " a b "
m = re.findall(r"\S+", text)
print(m)  # → ['a', 'b']
```

→ 空白を区切りとして非空白文字の連続部分を抽出。**トークン化・単語抽出**の基本に近い操作。

---

### 応用例①：前後の空白を除去せずに中間空白を検出

```python
text = "  user   name  "
spaces = re.findall(r"\s+", text)
print(spaces)  # → ['  ', '   ', '  ']
```

→ 複数空白を検出することで、「余分なスペースの検出や正規化」に活用可能。

---

### 応用例②：空白区切りでの入力検査

```python
pattern = r"\S+\s+\S+"
text = "first  second"

print(bool(re.fullmatch(pattern, text)))  # → True
```

→ 非空白文字列（単語）が2つ以上、**空白で区切られている**構造を検出できる。

---

### 応用例③：全体が空白文字のみかを検査

```python
print(bool(re.fullmatch(r"\s*", " \t\n")))  # → True
print(bool(re.fullmatch(r"\s*", "abc")))    # → False
```

→ 行末の空白除去や無意味な行の検出に利用される。

---

### よく使う組み合わせパターン

| パターン    | 意味       | 用途例            |
| ------- | -------- | -------------- |
| `\s+`   | 1文字以上の空白 | 空白区切り・複数空白の正規化 |
| `\S+`   | 非空白文字の連続 | 単語抽出、トークン処理    |
| `^\s*$` | 空白のみの行   | 無意味な行の除去       |
| `\s*`   | 空白0回以上   | 前後の柔軟な空白許容     |

---

### 注意点

* `\s` に一致するのは `" "`（スペース）だけでなく、改行やタブなども含まれる点に注意
* 行の先頭・末尾の空白処理は `.strip()` などと連携して使われることが多い
* 入力検証で使用する場合は、改行まで含まれると意図しない挙動になることがある（例：`\s+` が改行をまたぐ）

---

### 実務での用途

* **ユーザー入力の検証（先頭・末尾空白含むか）**
* **構造化されたログ・CSV・TSVのトークン分割**
* **コードやHTML中の無意味な空白除去**
* **自然言語処理における単語分割・空白統一**
* **非表示文字（空白類）の検出と可視化**

`\s` / `\S` は、文字列処理における\*\*「構文ではないが重要な構成要素」である空白類\*\*を扱うための基礎であり、**トークン処理・入力検査・整形処理に不可欠な構文**である。

---

## 24章：`\b`, `\B`（単語境界と非境界）

---

### 解説

`\b` は**単語境界（word boundary）にマッチするゼロ幅アサーション**であり、「単語構成文字 `\w` と、それ以外 `\W` の切れ目」に一致する。つまり、**単語の先頭や末尾にだけマッチし、実際の文字を消費しない**。

対して `\B` は **非単語境界（not word boundary）** に一致し、「単語の途中や、連続する非単語文字の間」にマッチする。

これにより、単語単位での厳密なマッチ、語頭／語末のみでの検索、あるいは**語中には含まれていても境界にない語の除外**など、高度なテキスト処理が可能になる。

---

### 基本使用例①：語頭または語末の検出（`\b`）

```python
import re

text = "python is fun. pythonista loves it."
matches = re.findall(r"\bpython\b", text)
print(matches)  # → ['python']
```

→ `pythonista` にはマッチしない。**単語として独立した `"python"` のみが対象**。

---

### 基本使用例②：非境界にマッチ（`\B`）

```python
text = "python is fun. pythonista loves it."
matches = re.findall(r"\Bpython\B", text)
print(matches)  # → []
```

→ `"python"` が\*\*語中に含まれる場合（前後が \w）\*\*にのみマッチするが、このケースでは該当なし。

---

### 応用例①：語尾に `"ed"` がつく単語だけを抽出

```python
text = "He walked and jumped, but not run."
matches = re.findall(r"\w+ed\b", text)
print(matches)  # → ['walked', 'jumped']
```

→ 単語の終端が `"ed"` のものだけを選別。`"redesign"` など語中 `"ed"` は除外される。

---

### 応用例②：語頭が `"re"` の単語抽出

```python
text = "react replay reread dream reality"
matches = re.findall(r"\bre\w+", text)
print(matches)  # → ['react', 'replay', 'reread', 'reality']
```

→ `"re"` で始まる単語を正確に抽出。`"dream"` は除外。

---

### 応用例③：`"man"` を語の一部としてだけ検出（`\B`）

```python
text = "man manager superman"
matches = re.findall(r"\Bman\B", text)
print(matches)  # → ['man']  （"superman" などは含まれない）
```

→ `"man"` の前後どちらも単語文字で囲まれているもののみ対象。

---

### ゼロ幅のための特徴

* `\b` や `\B` は「位置にマッチ」するだけで、文字自体は消費しない
* 他の正規表現との組み合わせで「語単位の厳密な検索」や「単語中の除外」が可能になる
* `\b` は非ASCII文字（漢字・ひらがな等）では正しく動作しないことがある（Pythonの仕様）

---

### よくある組み合わせパターン

| パターン       | 用途                 |
| ---------- | ------------------ |
| `\bword\b` | 単語として完全一致          |
| `\bpre\w*` | 特定接頭語を持つ単語         |
| `\w+ing\b` | `"ing"` で終わる動詞     |
| `\Bword\B` | 語中にある `"word"` の検出 |

---

### 注意点

* `\b` の「単語境界」は `\w` の定義に依存する（通常は `[a-zA-Z0-9_]`）
* Unicodeの漢字や仮名では `\b` は期待通りに動作しない → 単語境界を自前で処理する必要がある
* ゼロ幅のため `re.findall()` で位置を確認したい場合は `re.finditer()` を使うとよい

---

### 実務での用途

* **完全一致でのキーワード検出（部分一致除外）**
* **自然言語処理における語単位のマッチ**
* **マルチワード辞書による照合（語頭/語尾制限）**
* **不要な語中マッチの排除**
* **語尾変化のパターン認識（-ed, -ing, -ion など）**

`\b` / `\B` は、**テキスト構造を意識した精密なパターンマッチング**を実現するための重要な構文であり、キーワード照合や辞書処理など実務上の重要処理で頻繁に活用される。

---

## 25章：`\A`, `\Z`, `\z`（文字列の先頭・末尾）

---

### 解説

正規表現における `\A`, `\Z`, `\z` は、文字列全体の**論理的な開始・終了位置**にマッチするゼロ幅アサーションである。特に複数行処理や改行を含むデータにおいて、`^` / `$` とは異なる**厳密な先頭・末尾判定**が可能になる。

| 構文   | 意味                   | 改行の影響 |
| ---- | -------------------- | ----- |
| `\A` | **文字列の最初のみ**にマッチ     | 無視する  |
| `\Z` | **文字列の末尾または末尾の改行直前** | 改行許容  |
| `\z` | **文字列の厳密な末尾のみ**      | 改行不可  |

これらを用いると、全体の検査や完全一致判定など、**境界に敏感なバリデーション処理**が明示的に記述できる。

---

### 基本使用例①：`\A` による文字列先頭限定マッチ

```python
import re

text = "Hello\nWorld"
print(bool(re.match(r"\AHello", text)))  # → True
print(bool(re.search(r"^Hello", text, re.MULTILINE)))  # → True
```

→ `\A` は常に**文字列の先頭**だけにマッチ。`^` は `re.MULTILINE` によって各行頭にもマッチ可能だが、`\A` は1箇所限定。

---

### 基本使用例②：`\Z` と `\z` の違い

```python
text1 = "line1\nline2\n"
text2 = "line1\nline2"

print(bool(re.search(r"line2\Z", text1)))  # → True
print(bool(re.search(r"line2\z", text1)))  # → False
print(bool(re.search(r"line2\z", text2)))  # → True
```

→ `\Z` は末尾の改行を許容し、`\z` は完全な末尾でなければマッチしない。**ログやファイル終端の正確なマッチに使い分けられる。**

---

### 応用例①：完全一致チェック（`re.fullmatch()` 相当）

```python
pattern = r"\A[a-zA-Z0-9_]{8,20}\Z"
username = "user_name01"

print(bool(re.match(pattern, username)))  # → True
```

→ ユーザー名が**先頭から末尾まで**英数字とアンダースコアで構成されていることを検査。`^` / `$` より安全で意図が明確。

---

### 応用例②：ファイル終端マーカーの厳密チェック

```python
text = "header\nbody\n--EOF--"
print(bool(re.search(r"--EOF--\z", text)))  # → True
```

→ `--EOF--` が文字列末尾に**完全に存在するか**を確認。末尾に改行が入る場合は `\Z` を使う。

---

### 応用例③：複数行の中央部に `^` が反応する例と`\A`との違い

```python
text = "first line\nsecond line"

print(bool(re.search(r"^second", text, re.MULTILINE)))  # → True
print(bool(re.search(r"\Asecond", text, re.MULTILINE))) # → False
```

→ `^` は2行目でもマッチしてしまう。`\A` を使えば**1行目以外は常に無視**される。

---

### 用途別の使い分けまとめ

| 条件           | 使用する構文                        |
| ------------ | ----------------------------- |
| ファイル全体の先頭    | `\A`                          |
| ファイル末尾（改行OK） | `\Z`                          |
| ファイル末尾（改行NG） | `\z`                          |
| 各行の先頭・末尾     | `^`, `$`                      |
| 完全一致検査       | `\A...\Z` or `re.fullmatch()` |
| ファイル末尾マーカー検出 | `--END--\Z` や `\z`            |

---

### 注意点

* `\A` / `\Z` / `\z` は **改行の有無によって判定結果が異なる**
* `re.MULTILINE` による行単位の処理をしている場合でも、`\A` / `\Z` は**無視されない**
* `.fullmatch()` が Python で導入される前は、`re.match(r"\A...\Z")` というパターンで完全一致を表現していた

---

### 実務での用途

* **構成ファイル・テンプレートの先頭・末尾検査**
* **ユーザー入力やログ内容の完全一致バリデーション**
* **ファイル終端の改行有無に応じた厳密処理**
* **セキュリティ系処理での正確な構文制限**

`\A`, `\Z`, `\z` は、通常のアンカー構文では対応できない**文字列全体を対象とした高精度な境界制御**を可能にし、特に**完全一致系のバリデーションやファイル末尾処理で威力を発揮する**。

---

## 27章：名前付きグループ `(?P<name>...)`

---

### 解説

`(?P<name>...)` は、\*\*名前付きキャプチャグループ（named capturing group）\*\*を定義する構文である。通常のグループが数字（1, 2, 3...）でアクセスされるのに対し、名前付きグループでは `.group("name")` のように **意味のある名前でマッチ結果を取り出す**ことができる。

これにより、複数のグループがある場合の可読性が向上し、後続のコード処理や辞書展開にも応用しやすくなる。

---

### 基本使用例①：グループ名でアクセス

```python
import re

text = "Name: Alice, Age: 30"
pattern = r"Name: (?P<name>\w+), Age: (?P<age>\d+)"

m = re.search(pattern, text)
print(m.group("name"))  # → Alice
print(m.group("age"))   # → 30
```

→ 通常の `.group(1)` や `.group(2)` の代わりに、**意味のある識別子でアクセス可能**。

---

### 基本使用例②：辞書として取得（`.groupdict()`）

```python
print(m.groupdict())  # → {'name': 'Alice', 'age': '30'}
```

→ 名前付きグループは自動的に**辞書として取り出せる**ため、データ処理との相性が非常に良い。

---

### 応用例①：日付の構造化抽出

```python
pattern = r"(?P<year>\d{4})-(?P<month>\d{2})-(?P<day>\d{2})"
text = "2025-07-26"

m = re.match(pattern, text)
print(m.group("year"))   # → 2025
print(m.group("month"))  # → 07
print(m.group("day"))    # → 26
```

→ 各要素を明確に分離・命名して扱えるため、**データベース挿入やCSV変換などの前処理に適している。**

---

### 応用例②：複雑な構造から特定フィールドのみ取得

```python
log = "[ERROR] 2025-07-26 14:00:01 - file not found: config.yaml"
pattern = r"\[(?P<level>\w+)] (?P<date>\d{4}-\d{2}-\d{2}) (?P<time>\d{2}:\d{2}:\d{2})"

m = re.search(pattern, log)
print(m.groupdict())
# → {'level': 'ERROR', 'date': '2025-07-26', 'time': '14:00:01'}
```

→ ログ解析や構造化抽出に最適。

---

### 名前付きグループの利点まとめ

| 特徴         | 内容                                |
| ---------- | --------------------------------- |
| アクセス性向上    | `.group("name")` で読みやすく保守しやすい     |
| 辞書展開       | `.groupdict()` により変換・出力が容易        |
| グループ順依存を回避 | 順序を気にせず明示的な命名に基づいて取得できる           |
| 他形式への応用    | JSON, YAML, CSV などとのフィールド連携が簡単になる |

---

### 注意点

* `name` は **Pythonの識別子として有効な名前**でなければならない（英字＋数字＋アンダースコア、先頭は英字）
* 名前付きグループと通常の番号グループは **混在可能**（ただし管理が煩雑になるので慎重に）
* 名前付きグループでも `.group(n)` で番号アクセスは可能（番号割り当ては維持される）

---

### 実務での用途

* **フォーム・入力値の構造化とバリデーション**
* **ログ抽出のパターン設計とデータ整形**
* **スクレイピング結果のフィールド化**
* **設定ファイルやタグ付きデータの処理**
* **自動テストなどでの検出結果の検証**

`(?P<name>...)` は、正規表現のマッチ結果を「構造あるデータ」として扱う上で不可欠な構文であり、**Pythonによる文字列処理やデータ抽出の可読性・保守性を飛躍的に高める**手段となる。

---
## 28章：後方参照 `\1` や `(?P=name)`

---

### 解説

**後方参照（backreference）**とは、正規表現の中で**直前にマッチしたグループの内容を再利用して一致を検証する構文**である。

* `\1`, `\2`, ... は **番号による後方参照**（キャプチャグループ順）
* `(?P=name)` は **名前による後方参照**（名前付きグループ使用時）

これにより、「同じ内容の繰り返し」「開きと閉じが一致するタグ」など、**単純な文字列パターンでは表現しにくい一致条件**を簡潔に書ける。

---

### 基本使用例①：番号による後方参照 `\1`

```python
import re

text = "<tag>content</tag>"
pattern = r"<(\w+)>.*</\1>"

m = re.fullmatch(pattern, text)
print(bool(m))  # → True
```

→ 最初にマッチしたタグ名（例：`tag`）と、閉じタグが同じであることを**番号で強制している**。

---

### 基本使用例②：名前による後方参照 `(?P=name)`

```python
pattern = r"<(?P<tag>\w+)>.*</(?P=tag)>"
m = re.fullmatch(pattern, text)
print(bool(m))  # → True
```

→ 名前付きグループを用いることで、**構造と意味が明確になり、可読性が向上する。**

---

### 応用例①：重複単語の検出

```python
text = "This is is a test."
pattern = r"\b(\w+)\s+\1\b"

m = re.search(pattern, text)
print(m.group(0))  # → is is
```

→ 同じ単語が連続して使われている箇所を検出できる。**文章の自動校正や重複チェック**に応用される。

---

### 応用例②：同じ文字で囲まれた強調記法の検出（Markdownなど）

```python
text = "**bold**"
pattern = r"(?P<mark>\*{2})(.+?)\1"

m = re.fullmatch(pattern, text)
print(m.group(2))  # → bold
```

→ 強調マーク `**` で囲まれた中身を抽出。**マークが一致していることを強制する構文**として使われる。

---

### 応用例③：日付の区切り文字一致

```python
pattern = r"\d{4}([-/.])\d{2}\1\d{2}"
texts = ["2025-07-26", "2025/07/26", "2025.07.26", "2025-07/26"]

for text in texts:
    print(text, "→", bool(re.fullmatch(pattern, text)))
```

出力例：

```
2025-07-26 → True
2025/07/26 → True
2025.07.26 → True
2025-07/26 → False
```

→ 最初の区切り文字と同じものが使われているかを **構文的に保証**できる。

---

### 異なる構文の比較

| 構文          | 説明               | 使用条件          |
| ----------- | ---------------- | ------------- |
| `\1`, `\2`  | キャプチャ順に基づく後方参照   | 番号の管理が必要      |
| `(?P=name)` | 名前付きグループを使った後方参照 | 名前付きグループ定義が必要 |

---

### 注意点

* `\1` は **生のバックスラッシュ**なので、Pythonでは `"\\1"` のように **2重にエスケープ**する必要がある
* 名前付き参照 `(?P=name)` を使うと、**可読性や保守性が大幅に向上**する
* 後方参照はあくまで「マッチした文字列の再利用」であり、「正規表現パターンそのものの再利用」ではない

---

### 実務での用途

* **XML / HTML などのタグペアの整合性チェック**
* **マークアップ記法の一致検出（例：`**text**`, `__text__`）**
* **文章中の重複語句検出や誤り検出**
* **同一パターン内での構造保証**
* **ログやCSV中のフィールド構造の整合性検証**

後方参照は、文字列の**意味的な一貫性を保証するための仕組み**として極めて有用であり、特に「開きと閉じ」「繰り返し」「一致パターン」が必要なあらゆる場面で活用される。

---
## 29章：`(?=...)`, `(?!...)` の先読み・否定先読み

---

### 解説

`(?=...)` および `(?!...)` は、それぞれ **肯定先読み（positive lookahead）** と **否定先読み（negative lookahead）** と呼ばれるゼロ幅のマッチ条件である。
これらは「ある位置の**直後に特定のパターンがあるか（ないか）を条件にマッチングを制御**する」構文で、**対象部分を消費せずに条件付け**ができる。

* `(?=...)`：直後に特定のパターンが**続くときのみ**マッチ
* `(?!...)`：直後に特定のパターンが**続かないときのみ**マッチ

---

### 基本使用例①：肯定先読み `(?=...)`

```python
import re

text = "item1 item2 itemX"
matches = re.findall(r"item(?=\d)", text)
print(matches)  # → ['item', 'item']
```

→ `"item"` の直後に数字があるもの（`item1`, `item2`）だけを抽出対象にしている。`itemX` はマッチしない。

---

### 基本使用例②：否定先読み `(?!...)`

```python
matches = re.findall(r"item(?!\d)", text)
print(matches)  # → ['item']
```

→ `"item"` の直後に数字が**来ない**もの（`itemX`）のみ対象。

---

### 応用例①：特定文字を含まないメールアドレスを検出

```python
text = "user@example.com admin@x.org test@spam.com"
matches = re.findall(r"\b\w+@(?!spam\.com)\w+\.\w+", text)
print(matches)  # → ['user@example.com', 'admin@x.org']
```

→ `@spam.com` のような**特定のドメインを除外**したメールだけを抽出。

---

### 応用例②：数字のうち後ろに `%` がつかないものだけを検出

```python
text = "50 75% 80"
pattern = r"\d+(?!%)"
matches = re.findall(pattern, text)
print(matches)  # → ['50', '80']
```

→ `"75%"` は除外される。

---

### 応用例③：特定単語の直前のみを抽出（先読みと逆順）

```python
text = "Price: $100, Discount: $80"
matches = re.findall(r"\$\d+(?=,)", text)
print(matches)  # → ['$100']
```

→ カンマの直前にある金額だけを抽出。`$80` はマッチしない。

---

### 応用例④：パスワード強度検査の一部（先読み連結）

```python
pattern = r"^(?=.*[A-Z])(?=.*\d)[A-Za-z\d]{6,}$"
print(bool(re.fullmatch(pattern, "Passw0rd")))  # → True
print(bool(re.fullmatch(pattern, "password")))  # → False
```

→ **大文字を1文字以上、数字を1文字以上含み、かつ6文字以上**という複合条件を `(?=...)` で指定。

---

### `(?=...)` / `(?!...)` と他構文の違い

| 構文         | 機能             | 対象を消費するか | 用途例                |
| ---------- | -------------- | -------- | ------------------ |
| `(?=...)`  | 肯定先読み          | 否        | 次が数字かを確認（例: `\d`)  |
| `(?!...)`  | 否定先読み          | 否        | 次が `"X"` でないときに限定  |
| `(?<=...)` | 肯定後読み（第30章で解説） | 否        | 前が `"http"` のときに限定 |
| `(?<!...)` | 否定後読み（第30章で解説） | 否        | 前に `"@"` がない文字の検出  |

---

### 注意点

* Python の `re` モジュールは **可変長の先読み/後読みをサポートしない**
* 先読みで一致しても**マッチした部分には含まれない**ため、必要に応じて前後の構造と組み合わせる必要がある
* 組み合わせやネストによって複雑な条件が記述可能だが、**可読性に注意**

---

### 実務での用途

* **メールアドレスやURLの除外条件付き抽出**
* **後続の構造に依存したマッチ（記号・句読点・改行）**
* **強度チェックやフィルタ条件（パスワード・トークン）**
* **リッチテキストやマークアップ処理（構文の一致検査）**
* **正規表現の条件付き構造制御**

先読みと否定先読みは、**「ある条件が満たされた位置だけでマッチさせる」ための論理的フィルタ**であり、正規表現を実務で扱う際に不可欠な高度構文である。

---

## 30章：`(?<=...)`, `(?<!...)` の後読み・否定後読み

---

### 解説

`(?<=...)` および `(?<!...)` は、それぞれ **肯定後読み（positive lookbehind）** と **否定後読み（negative lookbehind）** にあたるゼロ幅アサーションである。
これは、「ある位置の**直前に特定のパターンがある（またはない）ことを条件にマッチを行う**」構文であり、**直前の文字列に基づいて条件付け**ができる。

* `(?<=...)`：**直前が**指定のパターンに一致する場合のみマッチ
* `(?<!...)`：**直前が**指定のパターンに一致しない場合にのみマッチ

いずれも対象文字列を「消費」せずに判定するため、**前後関係に依存する精密なマッチ条件**を記述するのに役立つ。

---

### 基本使用例①：肯定後読み `(?<=...)`

```python
import re

text = "¥500 $600"
pattern = r"(?<=¥)\d+"

print(re.findall(pattern, text))  # → ['500']
```

→ `¥` の直後にある数値だけを抽出。**`¥` を結果に含めずに**後続の数値だけを取得。

---

### 基本使用例②：否定後読み `(?<!...)`

```python
pattern = r"(?<!@)\b\w+\.com\b"
text = "user@example.com support@x.org site.com"

print(re.findall(pattern, text))  # → ['site.com']
```

→ `@` の直後ではない `.com` ドメインだけを抽出。メールアドレス部分は除外される。

---

### 応用例①：前が大文字の単語だけ抽出

```python
text = "Dr. Smith met mr. johnson"
pattern = r"(?<=\b[A-Z])[a-z]+"

print(re.findall(pattern, text))  # → ['r', 'mith']
```

→ 大文字1文字に続く小文字部分だけを抽出している。精密な文法抽出に役立つ。

---

### 応用例②：ピリオドの直後に続く英単語を取得（前がピリオドであること）

```python
text = "foo.bar baz.qux"
pattern = r"(?<=\.)\w+"

print(re.findall(pattern, text))  # → ['bar', 'qux']
```

→ `"."` の直後にある語を正確に抽出できる。

---

### 応用例③：前が `http://` のドメイン部分だけ取得

```python
text = "http://example.com and https://secure.com"
pattern = r"(?<=http://)\w+\.\w+"

print(re.findall(pattern, text))  # → ['example.com']
```

→ **httpで始まるURLのみを対象にして**、ドメインだけを抽出している。

---

### 構文一覧比較

| 構文         | 種類    | 判定対象の位置 | 結果に含まれるか | 用途例           |
| ---------- | ----- | ------- | -------- | ------------- |
| `(?=...)`  | 先読み   | **直後**  | 含まれない    | 数字の直前だけで一致させる |
| `(?!...)`  | 否定先読み | **直後**  | 含まれない    | 特定文字が後ろにない条件  |
| `(?<=...)` | 後読み   | **直前**  | 含まれない    | 特定記号の直後だけマッチ  |
| `(?<!...)` | 否定後読み | **直前**  | 含まれない    | 直前に特定語がない場合だけ |

---

### Pythonの制限

* Pythonの `re` モジュールでは、**後読みの長さは固定長に制限される**

  * OK: `(?<=http://)`
  * NG: `(?<=https?://)`（可変長）
* この制限により、**複雑な構文は分割処理や別の工夫が必要**となる
* `regex` モジュールを使えば可変長も許可される（拡張ライブラリ）

---

### 実務での用途

* **前方条件でマッチ範囲を限定（例：¥マーク後の金額抽出）**
* **マッチ対象を絞りつつ結果をシンプルに保つ（条件だけの付加）**
* **メール・URL・マークアップなど構造ある文字列の検査**
* **正規表現だけで複雑な前提条件を構築するロジックの簡素化**

後読み系構文は、文字列の**直前の内容に条件を付けて抽出処理を制御するための極めて強力なツール**であり、実務でもログ処理やテキスト解析において多用される。

---