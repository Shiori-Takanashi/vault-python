---
作成日時: 2025-07-26 20:58
変更日時: 土曜日 26日 7月 2025 20:58:47
---

# 第1部：基本知識

---

## 📍01章：`re` モジュール概要

---

### 📝解説

Pythonにおける正規表現の機能は、標準ライブラリのひとつである `re` モジュールを通じて提供される。このモジュールは、文字列のパターンマッチングや置換、分割、抽出といった多様な操作を支援する強力なツールである。Perl風の記法を継承しており、慣れ親しんだユーザーには特に扱いやすい。

基本的な使い方としては `import re` によってモジュールをインポートし、`re.search()`、`re.match()`、`re.findall()`、`re.sub()`、`re.compile()` などの関数を使用する。Pythonにおける正規表現の機能はシンプルだが、柔軟かつ拡張性があり、ファイル解析やログ抽出、データの前処理など、さまざまな局面で利用される。

また、Python 3以降はUnicodeへの対応も強化され、グローバルな文字列処理がより正確かつ安全に行えるようになった。たとえば、ASCIIとUnicodeのモード切り替え、全角・半角の考慮、サロゲートペア対応などがその例である。

---

### 📝基本構文と主要関数

| 関数名              | 概要                               |
| ---------------- | -------------------------------- |
| `re.search()`    | 文字列全体から最初に一致した部分を検索して返す          |
| `re.match()`     | 文字列の先頭に限定してパターンの一致を調べる           |
| `re.fullmatch()` | 文字列全体が完全に一致するかどうかを判定する           |
| `re.findall()`   | 一致したすべての文字列をリストとして返す             |
| `re.finditer()`  | 一致した各部分を `Match` オブジェクトのイテレータで返す |
| `re.sub()`       | 一致した部分を指定文字列に置換する                |
| `re.split()`     | 正規表現によって文字列を分割する                 |
| `re.compile()`   | 正規表現パターンを事前にコンパイルして再利用可能にする      |

---

### 📝基本使用例

```python
import re

text = "私の電話番号は090-1234-5678です。"
pattern = r"\d{2,4}-\d{2,4}-\d{3,4}"

result = re.search(pattern, text)
if result:
    print(result.group())  # → 090-1234-5678
```

この例では、3つの数字ブロックをハイフンで区切った電話番号形式に一致するパターンを `search()` によって検索している。

---

### 📝モジュールの特徴と設計意図

* **標準搭載**：Pythonにあらかじめ組み込まれており、外部ライブラリ不要
* **Perl準拠**：Perl系の豊富な正規表現表現に類似している
* **Unicode対応**：多言語における正確な文字列処理が可能
* **汎用性**：スクレイピング・データ前処理・ログ解析・入力チェックなどに活用
* **効率性**：`re.compile()` によって再利用を前提とした効率的処理が可能

---

### 📝CLIや他ライブラリとの連携可能性

`re` モジュールは、CLIツールやスクリプト処理との相性も良く、`click` や `argparse` といったCLI構築系ライブラリと組み合わせて、ユーザーから与えられた入力値に対する検査や補正処理に使われることも多い。また、`re` の知識は `BeautifulSoup`, `pandas`, `Pathlib`, `logging` 等の標準・外部ライブラリとの統合にも活かされる。これにより、開発者はより精密で安全な文字列制御を行うことができる。

---

### 📝注意点と誤解されがちな点

* `match()` は文字列の先頭しか対象にしないため、`search()` との違いを明確に把握すること
* Python文字列内で `\` を使うとエスケープされるため、正規表現文字列には生文字列（`r""`）の利用が推奨される
* `.`（任意の1文字）は改行にマッチしないことが多いため、必要に応じて `re.DOTALL` を用いる

---

## 📍02章：正規表現とは何か

---

### 📝解説

正規表現（Regular Expression）は、文字列のパターンを定義・検索・操作するための**小型の言語体系**であり、文字列処理を自動化・汎用化する上で不可欠な技術である。たとえば「日付形式の文字列をすべて抽出したい」「特定の接頭語を持つ単語だけ置換したい」「数字の羅列を検出したい」といった要件に対して、明確かつ柔軟に対応できる。

正規表現は数学的にも形式言語・オートマトン理論に基づいており、特に「有限オートマトンで判定可能な言語」を定義する表現法として発展してきた。実用面では、UNIX系のgrepやsed、Perl言語における記法が普及の礎を築いた。Pythonもこの流れを継承し、Perl互換の記法を採用している。

Pythonにおける正規表現の特長は、標準ライブラリ `re` を通じて統一的なAPIでアクセスでき、かつ複雑な構文やUnicode対応にも柔軟に対処できる点にある。

---

### 📝歴史的背景と進化

| 時代        | 主な出来事                                        |
| --------- | -------------------------------------------- |
| 1960年代    | 正規表現の数学的理論（形式言語・オートマトン）が確立される                |
| 1970年代    | UNIXの `ed`, `grep`, `sed` などに正規表現が導入される      |
| 1980〜90年代 | Perl が強力な正規表現エンジンを搭載し、事実上の業界標準となる            |
| 2000年代    | Python, JavaScript, JavaなどがPerl互換の正規表現を実装    |
| 2010年代〜   | Unicode対応、サロゲートペア処理、名前付きグループ、非貪欲マッチなど高機能化が進む |

---

### 📝正規表現の用途と有用性

#### 主な用途

* **バリデーション**（例：メールアドレスや電話番号の形式確認）
* **抽出**（例：HTMLタグ中のリンクや日付部分を抜き出す）
* **置換**（例：禁止語のマスキング、パス形式の変更）
* **分割**（例：空白やカンマなど複数種類の区切り文字でsplit）
* **ログ解析やデータ前処理**（例：構造化されていない生ログの整形）

#### 正規表現を用いると特に効果的な場面

| 処理対象        | 効果                        |
| ----------- | ------------------------- |
| 自由入力されたテキスト | 曖昧な構造に対応可能な検出と変換が可能       |
| 多言語・混合文字列   | Unicode対応によって幅広い表記への適応が可能 |
| 高速な前処理      | 単純な文字列走査よりも効率よくパターンを処理できる |

---

### 📝正規表現の読みやすさと複雑性

正規表現は「短く書けるが、読みにくい」というジレンマを伴うことがある。たとえば、以下のようなパターンは一見すると意味が掴みにくい：

```python
r"^(https?)://([\w.-]+)/(\d{4})/(\d{2})/(\d{2})$"
```

これは「HTTP/HTTPSから始まり、ドメイン、4桁年、2桁月、2桁日付を含むURL構造」を意味するが、初心者には難解である。Pythonでは `re.VERBOSE` モードを使うことで、空白やコメントを含んだ可読性の高い書き方も可能である。

---

### 📝他言語との比較

| 言語         | 正規表現サポート          | 特徴                      |
| ---------- | ----------------- | ----------------------- |
| Python     | 標準ライブラリ `re`      | Perl準拠。拡張性とUnicode対応が高い |
| Perl       | 組み込み機能            | 強力なパターン表現と高速性           |
| Java       | `java.util.regex` | オブジェクト指向的なAPI構造         |
| JavaScript | RegExpオブジェクト      | Web前提の簡易表現が中心           |

---

### 📝注意すべき設計思想

* **明示性重視**：Zen of Pythonに則り、あいまいなマッチより明確なマッチを優先
* **構文の整合性**：生文字列 `r""` を使うことでバックスラッシュの多重エスケープを避ける
* **代替手段の理解**：正規表現ではなく、構文解析（BeautifulSoupなど）が適している場面もある

---

## 📍03章：`re.search()` の使い方と挙動

---

### 📝解説

`re.search()` は、**文字列全体を対象にしてパターンがどこかに存在するかを調べる関数**である。返り値は一致した箇所の情報を持つ `Match` オブジェクトであり、一致しなければ `None` を返す。検索範囲が文字列の**先頭に限定されない**点が、`re.match()` との重要な違いである。

主に次のような目的で利用される：

* パターンの存在確認（条件分岐などに有用）
* 位置や内容の抽出（`group()`, `start()`, `end()` などで利用）
* 特定条件を満たす入力のスクリーニング（フォームバリデーションなど）

`re.search()` は実務上もっとも頻出の関数のひとつであり、「入力に特定パターンが含まれるかどうか」を調べる場面で多用される。

---

### 📝基本構文

```python
import re

result = re.search(パターン, 対象文字列)
```

返り値が `None` でなければ、一致があったことを意味する。さらに `Match` オブジェクトのメソッドで詳細を取得できる。

---

### 📝使用例と動作確認

```python
import re

text = "注文番号はA12345です。"
pattern = r"A\d+"

match = re.search(pattern, text)
if match:
    print("一致:", match.group())       # → 一致: A12345
    print("開始位置:", match.start())   # → 開始位置: 5
    print("終了位置:", match.end())     # → 終了位置: 11
else:
    print("一致なし")
```

この例では、「A」から始まり、続けて数字が並ぶパターンにマッチしている。結果として `A12345` が抽出される。

---

### 📝`re.search()` を用いた分岐パターン

フォーム入力などで使われる条件分岐の典型例：

```python
email = "example@test.co.jp"
if re.search(r"@.+\.", email):
    print("正しい形式の可能性あり")
else:
    print("形式エラー")
```

このように、`re.search()` は「部分一致があればTrue」というシンプルな判定条件として利用できる。

---

### 📝`None` 判定と例外防止

一致しない場合に `.group()` を呼び出すと `AttributeError` になるため、`match is not None` を先に判定するのが安全な実装である：

```python
m = re.search(r"\d+", "abc")
if m:
    print(m.group())
else:
    print("一致なし")
```

---

### 📝他の関数との比較

| 関数名           | 一致対象の範囲    | 主な用途         |
| ------------- | ---------- | ------------ |
| `search()`    | 文字列全体      | 部分一致の有無を確認   |
| `match()`     | 文字列の先頭のみ   | 形式チェック（先頭限定） |
| `fullmatch()` | 文字列全体が完全一致 | 厳密なフォーマット検証  |

---

## 📍04章：`re.match()` と `re.search()` の違い

---

### 📝解説

`re.match()` と `re.search()` はともに正規表現によるパターン探索を行う関数だが、検索範囲に決定的な違いがある。

* `re.match()`：**文字列の先頭**にパターンが存在する場合のみマッチ
* `re.search()`：**文字列全体のどこか**にパターンがあればマッチ

両者の選択を誤ると、「存在しているのに検出できない」「部分一致と誤解して処理が進んでしまう」といったバグの原因になる。バリデーションや形式チェックなど、**厳密に「先頭一致」が必要な場面では `re.match()`** を使うべきである。

---

### 📝使用例による違い

```python
import re

text = "ID: A1234"

# search は先頭以外にも反応する
m1 = re.search(r"A\d+", text)
print("search:", m1.group() if m1 else "なし")  # → A1234

# match は先頭に "A1234" がないので None
m2 = re.match(r"A\d+", text)
print("match:", m2.group() if m2 else "なし")   # → なし
```

---

### 📝`Match` オブジェクトの基本

両関数の戻り値は共通して `re.Match` オブジェクトであり、以下のメソッドで情報を取得できる：

| メソッド名          | 説明                     |
| -------------- | ---------------------- |
| `.group()`     | 一致した文字列全体を返す           |
| `.start()`     | 一致部分の開始インデックスを返す       |
| `.end()`       | 一致部分の終了インデックス（+1）を返す   |
| `.span()`      | `(start, end)` のタプルを返す |
| `.groups()`    | グループ化された部分（括弧）だけを返す    |
| `.groupdict()` | 名前付きグループがある場合に辞書で返す    |

例：

```python
m = re.search(r"(\d+)", "ID: 5123")
print(m.group())     # → 5123
print(m.start())     # → 4
print(m.span())      # → (4, 8)
```

---

### 📝使い分けの指針

| 用途                                | 推奨関数          |
| --------------------------------- | ------------- |
| 文字列の形式が **完全に先頭から一致** しているかを検証したい | `re.match()`  |
| 入力文字列内の **どこかにパターンが含まれるか** を検出したい | `re.search()` |

このように、使い分けを誤るとパターンが意図せず無視される可能性がある。特に `match()` は「検出されない」ことに気づきにくいため、仕様を正確に理解して選択する必要がある。

---

## 📍05章：`re.fullmatch()` の用途と違い

---

### 📝解説

`re.fullmatch()` は、**文字列全体がパターンに一致しているかどうかを厳密に検証する関数**である。`re.match()` が「先頭一致」、`re.search()` が「部分一致」であるのに対し、`re.fullmatch()` は**全文一致**のみを許容するため、最も制限が厳しい。

この関数は、バリデーション用途、特に「この文字列が完全にこの形式であるべきか？」という場面で非常に有効である。たとえば、郵便番号・電話番号・メールアドレスなどが「余計な前後の文字が一切ないこと」を保証する場合に使う。

---

### 📝基本使用例と挙動

```python
import re

text1 = "abc123"
text2 = "abc123xyz"

pattern = r"[a-z]{3}\d{3}"

m1 = re.fullmatch(pattern, text1)
m2 = re.fullmatch(pattern, text2)

print("text1:", m1.group() if m1 else "一致なし")  # → abc123
print("text2:", m2.group() if m2 else "一致なし")  # → 一致なし
```

この例では、`text1` は全体が `[a-z]{3}\d{3}` にマッチするが、`text2` は末尾の `xyz` が余計であるため、`re.fullmatch()` ではマッチしない。

---

### 📝バリデーション用途との親和性

フォーム検証や構文チェックでは、`re.fullmatch()` による**厳格な一致確認**が非常に有用である。たとえば、「3文字の英字＋4桁数字」という社員IDの検証は以下のように実装される：

```python
employee_id = "ABC1234"
if re.fullmatch(r"[A-Z]{3}\d{4}", employee_id):
    print("形式正しい")
else:
    print("形式不正")
```

---

### 📝`Match` オブジェクトの扱い

`re.fullmatch()` の戻り値も `Match` オブジェクトであるため、`.group()` や `.span()` などの操作が可能である。前章と同様に、`None` 判定と併用して処理を組み立てるのが基本となる。

---

### 📝他関数との違いの比較

| 関数名              | 一致条件               | 主な用途         |
| ---------------- | ------------------ | ------------ |
| `re.search()`    | 文字列のどこかに部分一致があればOK | 存在確認・抽出      |
| `re.match()`     | 文字列の先頭からの一致        | 書式確認（先頭）     |
| `re.fullmatch()` | 文字列全体が完全に一致する必要あり  | バリデーション・構文検証 |

---

### 📝注意点

* `^...$` を `re.search()` に使うことでも「全体一致」は可能だが、`re.fullmatch()` の方が**明示的かつ簡潔**である。
* `re.fullmatch()` を使用すれば、誤って余計な前後文字を許容することを防げる。

---

## 📍06章：`re.findall()` で全一致を取得

---

### 📝解説

`re.findall()` は、文字列内で正規表現に**一致するすべての部分文字列をリストで返す**関数である。`re.search()` や `re.match()` が1箇所の一致を対象にするのに対し、`re.findall()` は**全件抽出**が目的であり、**複数出現する要素を一括で取得したい場合**に非常に便利である。

返り値は `Match` オブジェクトではなく、**一致した文字列のリスト**となる。また、正規表現にグループ（`()`）が含まれている場合、その部分だけをリストで返す点にも注意が必要である。

---

### 📝基本使用例

```python
import re

text = "価格: 1200円, 割引後: 980円, 税込: 1078円"
pattern = r"\d+円"

matches = re.findall(pattern, text)
print(matches)  # → ['1200円', '980円', '1078円']
```

この例では「○○円」の形式で記述された金額すべてが抽出されている。

---

### 📝グループ使用時の挙動

```python
text = "氏名: 田中太郎, 年齢: 23歳 / 氏名: 山田花子, 年齢: 30歳"
pattern = r"氏名: (\w+), 年齢: (\d+)歳"

results = re.findall(pattern, text)
print(results)
# → [('田中太郎', '23'), ('山田花子', '30')]
```

このように、グループが存在すると `re.findall()` の返り値は「タプルのリスト」となる。各グループに対応した要素が順序通り格納される。

---

### 📝使用上の注意点

* `findall()` は **一致がなければ空リスト `[]` を返す**。`None` にはならない。
* **非グループ指定時は文字列単位で返却**、グループあり時は**グループ単位のリストやタプル**となる。
* グループが1つなら `['xxx', 'yyy']`、複数なら `[('x1', 'y1'), ('x2', 'y2')]` のような構造になる。

---

### 📝他関数との比較

| 関数名             | 目的         | 戻り値の型                         |
| --------------- | ---------- | ----------------------------- |
| `re.search()`   | 最初の1件の抽出   | `Match` オブジェクト                |
| `re.findall()`  | すべての一致を抽出  | `list[str]` または `list[tuple]` |
| `re.finditer()` | イテレータで逐次処理 | `iterator[Match]`             |

---

### 📝実務上の活用例

* **CSVやログファイルから複数の項目を一括抽出**
* **HTMLテキスト中のリンクURLをすべて抽出**
* **数値や日付などの出現パターンを一覧化**

このように `re.findall()` は、情報抽出系タスクにおいて頻繁に用いられる中核的な関数である。

---

## 📍07章：`re.finditer()` でイテレータ取得

---

### 📝解説

`re.finditer()` は、文字列中で正規表現に一致するすべての箇所を、`Match` オブジェクトとして**逐次的に走査可能なイテレータ**として返す関数である。`re.findall()` と異なり、得られるのは文字列そのものではなく、**一致情報を持つ完全なオブジェクト**であるため、次のような利点がある：

* 一致位置（`start()`, `end()`, `span()`）を取得できる
* グループ（`group(n)` や `groups()`）を保持している
* データ件数が多い場合でも**メモリ効率に優れる**

そのため、構文解析やログ抽出など、**高精度な文字列処理を要する場面で活躍する**。

---

### 📝利用例①：基本的な複数一致処理（インデックス付き）

```python
import re

text = "商品コード: ID123, ID999, ID001"
pattern = r"ID\d+"

for match in re.finditer(pattern, text):
    print(f"{match.group()} → 位置: {match.span()}")
```

出力例：

```
ID123 → 位置: (7, 12)
ID999 → 位置: (14, 19)
ID001 → 位置: (21, 26)
```

→ `.group()` で一致文字列、`.span()` で範囲（開始・終了インデックス）を取得できる。

---

### 📝利用例②：グループ抽出と順次処理

```python
html = "<div>タイトル</div><p>本文</p><span>補足</span>"
pattern = r"<(\w+)>(.*?)</\1>"

for m in re.finditer(pattern, html):
    tag, content = m.groups()
    print(f"{tag=}, {content=}, {m.span()=}")
```

出力例：

```
tag='div', content='タイトル', m.span()=(0, 20)
tag='p', content='本文', m.span()=(20, 32)
tag='span', content='補足', m.span()=(32, 49)
```

→ タグ名や内容を抽出しつつ、それぞれのタグ範囲も取得している。**構文解析**のような用途に適する。

---

### 📝利用例③：一致箇所をハイライト表示

```python
text = "電話番号: 090-1234-5678、FAX: 03-9876-5432"
pattern = r"\d{2,4}-\d{2,4}-\d{3,4}"

for m in re.finditer(pattern, text):
    s, e = m.span()
    highlighted = text[:s] + "[" + text[s:e] + "]" + text[e:]
    print(highlighted)
```

出力例（一部）：

```
電話番号: [090-1234-5678]、FAX: 03-9876-5432
電話番号: 090-1234-5678、FAX: [03-9876-5432]
```

→ 対象の番号を強調表示する処理。複数マッチの**順次強調や位置検出**に最適。

---

### 📝利用例④：辞書構造で抽出結果を整理

```python
text = "氏名:田中一郎 年齢:34歳 氏名:山田二郎 年齢:41歳"
pattern = r"氏名:(\S+)\s+年齢:(\d+)歳"

results = []
for m in re.finditer(pattern, text):
    name, age = m.groups()
    results.append({"name": name, "age": int(age)})

print(results)
```

出力例：

```
[{'name': '田中一郎', 'age': 34}, {'name': '山田二郎', 'age': 41}]
```

→ **抽出結果をデータ構造に整形**する際にも `finditer()` は便利。

---

### 📝`findall()` との比較表

| 比較項目      | `re.findall()`       | `re.finditer()`                     |
| --------- | -------------------- | ----------------------------------- |
| 戻り値       | 一致文字列（strまたはタプル）のリスト | `Match` オブジェクトのイテレータ                |
| 位置情報の取得   | 不可                   | `.start()`, `.end()`, `.span()` で可能 |
| メモリ効率     | 非効率（全件リスト化）          | 効率的（遅延評価）                           |
| 処理適合性     | 単純な抽出処理              | 高精度な処理・構造化処理                        |
| グループ情報の保持 | 文字列のみ                | `Match` オブジェクトで完全保持                 |

---

### 📝代表的な用途まとめ

* **構文解析**（タグ・構造・識別子の抽出）
* **ログ処理**（エラーやIPの位置付き抽出）
* **大量データ処理**（メモリ節約しつつ順次処理）
* **データ整形と構造化**（グループを辞書化して利用）
* **UI上の強調表示や抽出補助**（インデックス付き抽出）

`re.finditer()` は「一致箇所の詳細を持ったまま複数処理する」という観点で、**パターンの可視化・分析・構造化**に非常に強い力を発揮する。

---

## 📍08章：`re.sub()` による文字列の置換

---

### 📝解説

`re.sub()` は、文字列中で正規表現に一致した部分を**指定した別の文字列に置換する**関数である。文字列の前処理や機密情報のマスキング、不要部分の削除など、実務上非常に広範囲な応用がある。

基本構文は次の通り：

```python
re.sub(パターン, 置換文字列, 対象文字列, count=0)
```

* `パターン`：一致対象の正規表現
* `置換文字列`：マッチ部分を置き換える文字列
* `count`：置換の最大回数（0の場合は無制限）

また、置換文字列には**グループ参照**（`\1`, `\2`, `\g<name>`）や**関数コール**を指定できるため、静的・動的な加工処理の両方に対応できる。

---

### 📝利用例①：単純な文字列の置換

```python
import re

text = "foo and foo again"
new = re.sub(r"foo", "bar", text)
print(new)  # → bar and bar again
```

すべての "foo" が "bar" に置き換えられている。

---

### 📝利用例②：HTMLタグの除去

```python
html = "<p>Hello</p><div>World</div>"
clean = re.sub(r"<[^>]+>", "", html)
print(clean)  # → HelloWorld
```

簡易的なHTMLタグ除去に使える。ただし、入れ子構造や属性が複雑な場合は `BeautifulSoup` を使うべき。

---

### 📝利用例③：グループ参照による並び替え

```python
text = "山田 太郎"
pattern = r"(\w+)\s+(\w+)"
new = re.sub(pattern, r"\2 \1", text)
print(new)  # → 太郎 山田
```

姓と名の順序を入れ替える例。`(\w+)` でそれぞれキャプチャし、置換文字列で順番を逆転している。

---

### 📝利用例④：関数を使った動的置換

```python
def censor(m):
    return "*" * len(m.group())

text = "ID1234, ID56789"
masked = re.sub(r"ID\d+", censor, text)
print(masked)  # → ******, *******
```

ここでは一致した文字列の長さに応じて動的に `*` を出力しており、**マスキング処理の基本パターン**として応用できる。

---

### 📝利用例⑤：数値の正規化（カンマ除去）

```python
text = "1,200円 と 10,000円"
normalized = re.sub(r"(\d+),(\d+)", r"\1\2", text)
print(normalized)  # → 1200円 と 10000円
```

金額のカンマを削除し、数値処理に使える形式に変換している。

---

### 📝利用例⑥：先読みを使った制限付き置換

```python
text = "abc123XYZ456abc"
result = re.sub(r"\d+(?=XYZ)", "###", text)
print(result)  # → abc###XYZ456abc
```

この例では `"XYZ"` の直前にある数字だけを対象に置換しており、**先読み `(?=...)` と `sub()` を組み合わせることで精密な条件制御**が可能となる。

---

### 📝注意点と補足

* 置換後の文字列を返すのみで、元の文字列を直接変更しない（非破壊的操作）
* 関数を用いる場合、`Match` オブジェクトを受け取り、`.group()` や `.groups()` を用いて内容を参照できる
* 複雑なテンプレート置換や暗号化処理の前段にも有用

---

### 📝実務上の応用場面

| 用途       | 利用例                               |
| -------- | --------------------------------- |
| フィルタリング  | 禁止語、パスワードなどのマスク                   |
| クレンジング   | HTMLタグ除去、空白正規化、重複除去などのテキスト前処理     |
| フォーマット変換 | 日付や名前の順序変更、数値表記の統一                |
| ログ整形     | エラー番号のフォーマット統一、IPアドレスの一部隠蔽など      |
| セキュリティ対策 | ユーザー入力のサニタイズ、XSS/SQLインジェクションの対処など |

---
## 📍09章：`re.split()` による文字列の分割

---

### 📝解説

`re.split()` は、正規表現を**区切り文字として利用するsplit関数**である。標準の `str.split()` が「固定の文字列」を区切りに用いるのに対し、`re.split()` は**パターンに基づいた柔軟な分割**が可能であり、複数の記号や不規則な空白、数字・単語の境界などにも対応できる。

特に、複数種の区切り記号が混在していたり、入力データが不揃いなログやCSVの前処理において、その真価を発揮する。

---

### 📝基本使用例：複数記号による分割

```python
import re

text = "apple;banana,grape orange"
result = re.split(r"[;, ]+", text)
print(result)  # → ['apple', 'banana', 'grape', 'orange']
```

→ `;` または `,` またはスペースが連続しても、すべて正しく1区切りとして処理される。

---

### 📝応用例①：空白やタブの混在をまとめて処理

```python
line = "  ID\t\tName   Age \tLocation"
cols = re.split(r"\s+", line.strip())
print(cols)  # → ['ID', 'Name', 'Age', 'Location']
```

→ `\s+` によって**空白・タブ・改行などすべての空白文字**を1つの区切りとして扱える。

---

### 📝応用例②：数字の前後で単語を分離

```python
s = "error1warning2fatal3"
words = re.split(r"\d+", s)
print(words)  # → ['error', 'warning', 'fatal', '']
```

→ 数字を区切りとして分割し、**エラー種類の抽出やトークン化**に活用できる。

---

### 📝応用例③：キャプチャグループを使った境界保持

```python
expr = "1+2-3*4"
parts = re.split(r"([+\-*/])", expr)
print(parts)  # → ['1', '+', '2', '-', '3', '*', '4']
```

→ グループ `()` を使うと**分割記号も結果に含まれる**。式のトークン化や構文解析に非常に便利。

---

### 📝応用例④：連続区切り記号の無視

```python
text = "apple,,banana,,,orange"
res = re.split(r",+", text)
print(res)  # → ['apple', 'banana', 'orange']
```

→ `re.split()` は **連続した区切り記号の吸収**が得意。空欄を意味しない場合にはこの特性が重要となる。

---

### 📝注意点と補足

* **一致しない箇所をすべて残す**という点では、`re.findall()` とは逆の操作と言える。
* **区切りパターンにマッチした部分は出力に含まれない**が、グループを使えば明示的に保持可能。
* 末尾に区切り記号がある場合、最後の要素が空文字列になることもある。

---

### 📝他関数との使い分け

| 処理目的        | 適した関数          | 特徴               |
| ----------- | -------------- | ---------------- |
| 正確な区切りによる分割 | `str.split()`  | シンプルで高速、パターン非対応  |
| 複雑な記号・複数区切り | `re.split()`   | パターンベースで柔軟な分割が可能 |
| 抽出（取り出す）    | `re.findall()` | 一致した部分を得る        |
| 除去（消す）      | `re.sub()`     | 一致部分を削除または置換     |

---

### 📝実務での応用場面

* **CSV/TSVなど形式が不安定なログファイルの分割**
* **自然言語処理前のトークン分割処理**
* **複数の記号や句読点で文章を切る処理**
* **式やコードの構文的なパーツの抽出**

このように `re.split()` は、「分け方が曖昧・多様」なケースにおいて、**パターンによる制御された分割処理**を実現する手段として重要である。

---
## 📍10章：`re.compile()` によるパターンの事前コンパイル

---

### 📝解説

`re.compile()` は、正規表現パターンを**事前にコンパイルして使い回すための関数**である。通常、`re.search()` や `re.findall()` などに直接パターン文字列を渡す方法でも動作するが、**同じパターンを複数回使う場合**は `re.compile()` によって**正規表現オブジェクト**として保持する方が効率的かつ可読性も高くなる。

この関数は次のような利点を持つ：

* 処理速度の向上（パターン解析が一度きり）
* フラグの共通指定が可能（`re.IGNORECASE` 等）
* 関数呼び出しとの分離による**コードの整理**
* テストやテンプレート化がしやすい

---

### 📝基本構文

```python
pattern = re.compile(パターン文字列, フラグ)
match = pattern.search(対象文字列)
```

`pattern` は `Pattern` オブジェクトであり、`.search()` や `.match()` などの**同名メソッドを持つ**。

---

### 📝利用例①：複数箇所で同じパターンを再利用

```python
import re

regex = re.compile(r"\d{4}-\d{2}-\d{2}")  # 日付パターン

dates = [
    "生年月日: 1990-05-12",
    "取得日: 2021-11-30",
    "更新日: 2018-07-01"
]

for line in dates:
    m = regex.search(line)
    if m:
        print(m.group())
```

→ 毎行に同じパターンを適用する場面で `compile()` による事前定義が有効。

---

### 📝利用例②：フラグ指定とセットで再利用

```python
pattern = re.compile(r"error", re.IGNORECASE)

print(bool(pattern.search("Error detected")))
print(bool(pattern.search("no ERROR here")))
```

→ `re.IGNORECASE` などの**フラグを統一的に設定**できる。

---

### 📝利用例③：関数引数としてパターンを渡す

```python
def extract_words(text, pattern):
    return pattern.findall(text)

p = re.compile(r"\b\w+\b")
words = extract_words("Hello, world! 123", p)
print(words)  # → ['Hello', 'world', '123']
```

→ **関数設計とパターン定義を分離**することで、柔軟で再利用性の高い構成になる。

---

### 📝利用例④：複数パターンの管理（辞書化）

```python
rules = {
    "email": re.compile(r"\b[\w.%+-]+@[\w.-]+\.\w+\b"),
    "phone": re.compile(r"\d{2,4}-\d{2,4}-\d{3,4}")
}

text = "連絡先: taro@example.com または 03-1234-5678"

for label, pat in rules.items():
    m = pat.search(text)
    if m:
        print(f"{label}: {m.group()}")
```

→ 複数種のパターンを辞書などで**テンプレート的に運用可能**となる。

---

### 📝`Pattern` オブジェクト

| メソッド名          | 説明                |
| -------------- | ----------------- |
| `.search()`    | 最初に一致する部分を検索      |
| `.match()`     | 文字列の先頭に一致するか確認    |
| `.fullmatch()` | 文字列全体が一致するか確認     |
| `.findall()`   | 一致したすべての部分を取得     |
| `.finditer()`  | `Match` のイテレータを返す |
| `.sub()`       | 一致部分を置換           |
| `.split()`     | パターンによる分割処理       |

---

### 📝注意点と補足

* `re.compile()` は**正規表現のパースを一度だけ実行する**ため、同一パターンを大量に使う場合に有利
* `re.compile()` によって作られたオブジェクトを使うと、コードが**手続き的でなく宣言的になる**（パターン＝処理方針）

---

### 📝実務での利用シーン

* フォームバリデーションにおける複数フィールドの一括処理
* パターンマッチ処理のテンプレート化
* テストスイートやデータ抽出ライブラリにおける事前定義
* LLMやデータパイプラインにおける**正規表現の動的生成とキャッシュ**

`re.compile()` を用いることで、正規表現処理の構造化・最適化が可能となり、大規模なテキスト処理や再利用性の高いツール設計において必須となる。

---