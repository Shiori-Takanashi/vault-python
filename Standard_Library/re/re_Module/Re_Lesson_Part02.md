---
作成日時: 2025-07-26 21:17
変更日時: 土曜日 26日 7月 2025 21:17:37
---

# 📍第2部：基本メタ文字

---

## 11章：`.`（任意の1文字）

---

### 解説

正規表現における `.`（ドット）は、**改行 `\n` を除く任意の1文字**に一致する特殊メタ文字である。非常に柔軟で強力なため、**汎用パターンの一部**として多用される。ただし、使い方によっては**マッチ範囲が広すぎる**（過剰一致）リスクもあるため、制御方法と併用が重要となる。

---

### 基本の挙動

```python
import re

text = "cat cot cut"
result = re.findall(r"c.t", text)
print(result)  # → ['cat', 'cot', 'cut']
```

→ `"c"` に続いて任意の1文字、最後に `"t"` で構成される3文字列をすべて抽出している。

---

### 改行との関係と `re.DOTALL`

`.` はデフォルトで **改行 `\n` にはマッチしない**。改行も対象に含めたい場合は、**フラグ `re.DOTALL`（別名 `re.S`）** を明示的に指定する：

```python
text = "abc\ndef"
m = re.search(r"abc.def", text)  # 改行をまたぐ場合はマッチしない
print(m)  # → None

m2 = re.search(r"abc.def", text, re.DOTALL)
print(m2.group())  # → abc\ndef
```

→ 改行を含めて1文字扱いにしたいケースでは、`re.DOTALL` の併用が必須。

---

### 応用例①：ファイル拡張子の抽出

```python
filename = "report.final.pdf"
m = re.search(r"\.\w+$", filename)
print(m.group())  # → .pdf
```

→ `"."` はリテラルとして扱いたいため、`\.` と明示的にエスケープする必要がある（`re.search(r".pdf", ...)` は `xpdf` などにも誤マッチする）。

---

### 応用例②：動的な部分を吸収する

```python
line = "user42: ok"
if re.match(r"user..: ok", line):
    print("構文一致")
```

→ ユーザー番号などの部分に2桁の数字が入ると仮定し、`.` を2つ並べて任意2文字にマッチさせている。

---

### 注意点と誤用例

| 誤用例               | 問題点                    |
| ----------------- | ---------------------- |
| `".*"`            | 改行を含まないと過信すると失敗することがある |
| `"." を使ってリテラルを検索` | `"."` は特殊文字なのでエスケープが必要 |
| `.*?` の使い忘れ       | 貪欲すぎる一致を引き起こす可能性       |

---

### まとめ

* `.` は **改行以外の1文字** にマッチする
* 改行も対象にしたい場合は **`re.DOTALL` フラグ**が必要
* 安易な使用で **過剰一致や誤検出** を招くため、使用範囲を限定・確認すべき
* リテラルの `"."` を扱う場合は **`\.` とエスケープ**

このように、`.` は強力だが、**前後条件やフラグと組み合わせた正確な制御**が不可欠なメタ文字である。

---

## 12章：`^`（行頭）と `$`（行末）

---

### 解説

`^` と `$` は、正規表現で**文字列の位置（境界）を表すアンカー**である：

* `^`：文字列、または行の**先頭**に一致
* `$`：文字列、または行の**末尾**に一致

これらは特定の単語やパターンが「文頭や文末に出現すること」を検出するために用いられる。単なる部分一致とは異なり、**正確な位置に限定したマッチング**が可能となる。

---

### 基本使用例：先頭／末尾の一致確認

```python
import re

line = "ERROR: Disk full"

# 先頭に "ERROR" があるか確認
print(bool(re.search(r"^ERROR", line)))  # → True

# 末尾が "full" で終わるか確認
print(bool(re.search(r"full$", line)))  # → True
```

---

### 複数行テキストへの適用と `re.MULTILINE`

通常の正規表現では `^` や `$` は**文字列全体の先頭／末尾**にしか反応しない。だが、`re.MULTILINE` フラグを使用すると、**各行の先頭・末尾**にマッチできるようになる：

```python
text = "ERROR: failed\nOK: success\nWARNING: unstable"

# 各行の "OK" から始まる行を検出
matches = re.findall(r"^OK.*", text, re.MULTILINE)
print(matches)  # → ['OK: success']
```

→ 複数行ログ処理などで、**行単位のフィルタリング**に役立つ。

---

### 実用例①：コメント行や空行の検出

```python
text = "# コメント行\n\nprint('Hello')"
lines = text.splitlines()

# 空行・コメント行の検出
for line in lines:
    if re.match(r"^\s*$", line) or re.match(r"^\s*#", line):
        print("スキップ対象:", repr(line))
```

→ `^\s*$` によって空行を、`^\s*#` によって先頭に `#` を含むコメント行を判定。

---

### 実用例②：完全一致の代替としての `^...$`

```python
text = "abc123"
pattern = r"^[a-z]{3}\d{3}$"

if re.match(pattern, text):
    print("構文一致")
```

→ `re.fullmatch()` が使えない環境でも `^...$` を使えば**全文一致**と同等のチェックが可能。

---

### 注意点

| 誤用・盲点               | 説明                                  |
| ------------------- | ----------------------------------- |
| `^` を部分一致と誤解する      | これは\*\*「先頭限定」\*\*。途中の "abc" には反応しない |
| `$` で改行後の空白に気づかない   | `$` は**行末の改行の直前**にマッチする。改行そのものではない  |
| `re.MULTILINE` を忘れる | 各行の `^` `$` を活用する場合はこのフラグが必須        |

---

### まとめ

* `^` は行や文字列の先頭、`$` は末尾にマッチする
* 行単位の検出には `re.MULTILINE` フラグが必要
* `^...$` を使うことで簡易的な**全体一致チェック**が可能
* フォームバリデーションやログ行抽出、構文検証など、**正確な構造チェック**に広く応用される

位置を意識したマッチ処理において、`^` と `$` は最も基本かつ重要なアンカーである。

---

## 13章：`*`（0回以上の繰り返し）

---

### 解説

`*` は、直前の文字またはグループが**0回以上（0回を含む）繰り返される部分にマッチ**するメタ文字である。任意回数の繰り返しを許容するため、非常に汎用性が高く、「存在するかもしれない要素」「長さが不定な入力」に対応できる。

ただし、`*` はデフォルトで**貪欲（greedy）**に動作するため、可能な限り長く一致させようとする。過剰一致のリスクを避けるには**非貪欲化**（`*?`）と併用する必要がある。

---

### 基本使用例：0回以上の繰り返し

```python
import re

text = "aaaaab"
m = re.fullmatch(r"a*b", text)
print(m.group())  # → aaaaab
```

→ `"a"` が何回あっても（0回でも）よく、その後 `"b"` が来れば一致。

```python
text = "b"
print(bool(re.fullmatch(r"a*b", text)))  # → True（"a" が 0 回でも OK）
```

---

### 応用例①：タグの内容抽出（過剰一致に注意）

```python
html = "<div>abc</div><div>def</div>"
m = re.search(r"<div>.*</div>", html)
print(m.group())  # → <div>abc</div><div>def</div>
```

→ `.*` によりすべてを吸収し、**最初の `<div>` から最後の `</div>` までマッチ**してしまう。これは「貪欲すぎる一致」による典型的な誤動作。

---

### 応用例②：非貪欲マッチで範囲を制限

```python
m = re.search(r"<div>.*?</div>", html)
print(m.group())  # → <div>abc</div>
```

→ `*?` によって「可能な限り短く」一致し、**個別タグごとの抽出**が可能となる。

---

### 応用例③：オプション記述を含む形式の許容

```python
s = "user:1234"
print(bool(re.fullmatch(r"user:.*", s)))  # → True

s2 = "user:"
print(bool(re.fullmatch(r"user:.*", s2)))  # → True（何もないのも許容）
```

→ `.*` により、「指定がある場合もない場合も」同じパターンで許容できる。

---

### 比較：`*` と他の繰り返しメタ文字

| メタ文字 | 説明        | 例 `"a"` に対しての一致          |
| ---- | --------- | ------------------------ |
| `*`  | 0回以上の繰り返し | `""`, `"a"`, `"aaa"` など  |
| `+`  | 1回以上の繰り返し | `"a"`, `"aaa"`（`""` は不可） |
| `?`  | 0回または1回   | `""`, `"a"`              |

---

### 注意点

* `.*` は最も広く一致するパターンであるため、**制限のない使用は危険**（文脈に依存）
* グループと組み合わせると **繰り返し対象が広がる**：`(abc)*` は `"abcabc"` に一致
* 改行を含むかどうかは `re.DOTALL` の有無で決まる

---

### 実務での活用場面

* **ログ解析**におけるフリーフォーマット行の抽出
* **タグ・テンプレート文字列の解析**（ただし慎重な設計が必要）
* **オプションパラメータの検出**（存在しない可能性もある項目）

`*` は「何文字でも許容する」という性質を持ち、柔軟だが強力すぎるため、**使い方とスコープ制御が常に重要**となる。

---

## 14章：`+`（1回以上の繰り返し）

---

### 解説

`+` は、正規表現において**直前の文字やグループが1回以上繰り返される部分にマッチ**するメタ文字である。`*`（0回以上）と似ているが、`+` は**最低1回の出現が必須**という点で異なる。

そのため、「空ではない繰り返しを許容したい」「必須フィールドを検証したい」場合に `+` は適しており、**パターンの厳格さを維持したいバリデーション**で特によく使用される。

---

### 基本使用例

```python
import re

print(bool(re.fullmatch(r"a+b", "aaab")))  # → True
print(bool(re.fullmatch(r"a+b", "b")))     # → False（"a" が1回もない）
```

→ `"a"` は1回以上必要なため、 `"b"` だけでは一致しない。

---

### 応用例①：少なくとも1文字の単語にマッチ

```python
text = "This is  an   example."
words = re.findall(r"\w+", text)
print(words)  # → ['This', 'is', 'an', 'example']
```

→ `\w+` によって、1文字以上の英数字・アンダースコアで構成された**単語単位の抽出**が可能。

---

### 応用例②：メールアドレスの前半部分の検出

```python
email = "taro.yamada@example.com"
m = re.match(r"\w+[\w.]+", email)
print(m.group())  # → taro.yamada
```

→ `+` によって、**1文字以上の連続パターンを確保**することで、部分的なパースが可能になる。

---

### 応用例③：桁数の保証

```python
print(bool(re.fullmatch(r"\d+", "12345")))  # → True
print(bool(re.fullmatch(r"\d+", "")))       # → False
```

→ 数字列のバリデーションでは、**1桁以上の数値であること**を保証したい場合、`\d+` が便利。

---

### `+` と `*` の比較

| パターン | 対象       | マッチ可否 | 説明       |
| ---- | -------- | ----- | -------- |
| `a*` | `""`     | ○     | 0回でも一致する |
| `a+` | `""`     | ✕     | 最低1回必要   |
| `a+` | `"a"`    | ○     | 1回なのでOK  |
| `a+` | `"aaaa"` | ○     | 複数回でもOK  |

---

### 非貪欲化との併用：`+?`

```python
html = "<b>強調</b><b>注意</b>"
tags = re.findall(r"<b>.+?</b>", html)
print(tags)  # → ['<b>強調</b>', '<b>注意</b>']
```

→ `+` は通常**貪欲（できるだけ長く）**に動作するため、必要に応じて `+?`（非貪欲）にすることで**意図した短い範囲に限定**できる。

---

### 実務での利用場面

* **非空の入力を許容するバリデーション**

  * 例：ユーザー名・パスワード・数値フィールド
* **トークン単位の抽出**

  * 例：単語・数字列・記号列の切り出し
* **最低1件のパターンマッチ**

  * 例：リスト形式の1件以上の項目検出
* **構造の一貫性確認**

  * 例：日付・ファイル名・タグ列などの形式保証

---

### 注意点

* `+` は柔軟だが「最低1回は必須」という**前提を強制する**
* 空文字列との一致を許したくないときに必須
* **非貪欲化との使い分け**が、特にHTMLなどでは重要


`+` は「ある程度の必須性を持たせたいが、回数に幅がある」パターンにおいて、**精密で安全な検出の要となる記号**である。

---
## 15章：`?`（0回または1回）

---

### 解説

`?` は、直前の文字またはグループが\*\*「あってもなくてもよい（最大1回）」\*\*という繰り返し条件を意味するメタ文字である。選択的な要素やオプション記法に対応するための基本的な記号であり、入力パターンが「ある場合とない場合が混在する」ような場面で特に効果を発揮する。

また、`?` は他にも以下のような役割を持つ：

* `*?`, `+?`, `??` の形で用いられたとき → **非貪欲モード（lazy）** を指示する
* `(?...)` との組み合わせ → **先読み・後読み・グループ指定** などの文法制御

この章では、**0回または1回の繰り返し**としての使用に絞って解説する。

---

### 基本使用例：オプション要素の許容

```python
import re

pattern = r"https?://"

print(bool(re.match(pattern, "http://example.com")))   # → True
print(bool(re.match(pattern, "https://example.com")))  # → True
```

→ `s?` の部分により、`http` または `https` の両方にマッチできる。

---

### 応用例①：ハイフンやスペースの有無を許容

```python
pattern = r"\d{3}-?\d{4}"
matches = re.findall(pattern, "1234567 123-4567")
print(matches)  # → ['1234567', '123-4567']
```

→ `-?` により、\*\*「ハイフンがあってもなくてもよい」\*\*形式に対応。

---

### 応用例②：日付フォーマットの柔軟な処理

```python
dates = ["2024/01/01", "2024-01-01", "20240101"]
pattern = r"\d{4}[-/]?\d{2}[-/]?\d{2}"

for d in dates:
    if re.fullmatch(pattern, d):
        print("マッチ:", d)
```

→ `/` や `-` を含むかどうかに関わらず、**同一の正規表現で処理**できる。

---

### 注意点：`??` は別の意味になる

```python
text = "abcabc"
m = re.search(r"a??b", text)
print(m.group())  # → 'b'
```

→ `??` は「非貪欲で0回または1回」の意味となり、**過剰一致の防止**に使われる（後述のメタ的構文扱い）。

---

### 他の繰り返し記号との比較

| パターン | 意味             | マッチ例                 |
| ---- | -------------- | -------------------- |
| `a?` | `"a"` が0回または1回 | `""`, `"a"`          |
| `a*` | 0回以上           | `""`, `"a"`, `"aaa"` |
| `a+` | 1回以上           | `"a"`, `"aaa"`       |

---

### 実務での用途

* **HTTP/HTTPSなどプロトコルの違いを吸収**：`https?://`
* **ハイフン・区切り記号が入ることがあるIDや番号の処理**
* **「省略可」なフィールドの検出**（例：姓と名の間にスペースがあるか不定）
* **日付・電話番号など多様な記法への柔軟対応**

---

### 誤用に注意すべき点

| ケース             | 問題点                          |
| --------------- | ---------------------------- |
| `?` を「任意の文字」と誤解 | 任意の文字は `.`。`?` は「0回または1回」    |
| `??` の意味を誤解     | 非貪欲の記号であり、通常の `?` とは異なる      |
| 連続使用時の読みづらさ     | `(abc)?(def)?` のような構造は括弧で明確に |


`?` は、**選択性のある構造を正規表現に柔軟に導入するための基本的な記号**であり、**省略可・任意の有無**が要求される入力の処理に不可欠である。入力バリエーションへの適応力を高めるため、正確な意味を理解して使うべきである。

---

## 16章：`{m}`, `{m,n}` の繰り返し制御

---

### 解説

`{m}` および `{m,n}` は、**繰り返し回数を明示的に指定するためのメタ構文**である。先述の `*`（0回以上）、`+`（1回以上）、`?`（0回または1回）と比較して、**回数を正確にコントロールしたい場面において圧倒的な精度**を持つ。

* `{m}`：ちょうど m 回の繰り返し
* `{m,n}`：m 回以上、n 回以下の繰り返し
* `{m,}`：m 回以上（上限なし）
* `{,n}`：Pythonでは非対応（mは省略できない）

この指定により、**バリデーション・桁数チェック・文字数制限**といった精密なルールの実装が可能になる。

---

### 基本使用例①：ちょうどの回数 `{m}`

```python
import re

print(bool(re.fullmatch(r"\d{4}", "2024")))   # → True
print(bool(re.fullmatch(r"\d{4}", "24")))     # → False
```

→ `\d{4}` によって「4桁の数字のみ」が許可される。

---

### 基本使用例②：範囲 `{m,n}`

```python
pattern = r"\w{3,5}"
print(re.findall(pattern, "abc abcd abcde abcdef"))  
# → ['abc', 'abcd', 'abcde', 'abcde']
```

→ 3〜5文字の単語にマッチしており、6文字以上のものは対象外。

---

### 応用例①：郵便番号の検証（3桁-4桁）

```python
pattern = r"\d{3}-\d{4}"
print(bool(re.fullmatch(pattern, "123-4567")))  # → True
```

→ 厳密な桁数指定で、日本の郵便番号形式を検出。

---

### 応用例②：電話番号の柔軟な処理

```python
pattern = r"\d{2,4}-\d{2,4}-\d{3,4}"
m = re.fullmatch(pattern, "03-1234-5678")
print(bool(m))  # → True
```

→ 地域により桁数が異なる電話番号を、範囲指定により吸収している。

---

### 応用例③：長さ制限付きパスワードチェック

```python
pw = "abc123XYZ"
pattern = r"[a-zA-Z0-9]{8,16}"
print(bool(re.fullmatch(pattern, pw)))  # → True
```

→ 英数字で構成された8〜16文字の文字列であるかを正確に検査。

---

### メタ文字との比較表

| 記号       | 意味      | `a` の例                    | 備考                   |
| -------- | ------- | ------------------------- | -------------------- |
| `a*`     | 0回以上    | `""`, `"a"`               | 最も緩い制約               |
| `a+`     | 1回以上    | `"a"`, `"aaa"`            | 空文字を除外               |
| `a?`     | 0回または1回 | `""`, `"a"`               | 単一存在の有無              |
| `a{3}`   | ちょうど3回  | `"aaa"`                   | `"aa"`や`"aaaa"`は不一致  |
| `a{2,4}` | 2〜4回の範囲 | `"aa"`, `"aaa"`, `"aaaa"` | `"a"`や `"aaaaa"` は除外 |

---

### 注意点

* `{}` はリテラルとして使う場合エスケープが必要：例：`\{a\}`
* 範囲 `{m,n}` の上限 `n` を省略する形式 `{m,}` はサポートされるが、逆 `{,n}` はエラー
* コンマを含むため **読点としての使用と区別が必要**

---

### 実務での用途

* **桁数が固定されたID（郵便番号・社員番号）などの検出**
* **パスワード長・入力制限の実装**
* **日付・時間・電話番号などの形式検証**
* **可変要素を含むテンプレートの検証**
* **構文エラー検出：足りない・長すぎる入力の拒否**

繰り返しを明示的に制限できる `{}` の構文は、**安全で厳密な検査・抽出を行うための基盤**として、バリデーション・抽出処理において中心的な役割を果たす。

---

## 17章：`[]` 文字クラスと `[^]` 否定

---

### 解説

`[]` は、文字クラス（character class）を定義するための構文であり、**指定された文字のいずれか1文字に一致**する。特定の文字だけを許可したい場合や、範囲を指定して英数字や記号をまとめて扱いたい場合に使用される。

一方、`[^]` のように `^` を先頭に置くと、**否定クラス（not）**となり、「指定された文字**以外**の1文字」に一致する。この対構造により、柔軟な入力制限や除外パターンの構築が可能となる。

---

### 基本使用例①：文字の集合にマッチ

```python
import re

text = "cat bat rat"
matches = re.findall(r"[cbr]at", text)
print(matches)  # → ['cat', 'bat', 'rat']
```

→ `"c"`, `"b"`, `"r"` のいずれかで始まり、`"at"` に続く単語を抽出。

---

### 基本使用例②：否定クラス `[^]`

```python
text = "1 + 2 - 3 * 4 / 5"
ops = re.findall(r"[^0-9\s]", text)
print(ops)  # → ['+', '-', '*', '/']
```

→ 数字 (`0-9`) と空白 (`\s`) 以外のすべての1文字に一致し、**演算記号だけを抽出**している。

---

### 応用例①：英数字と記号の範囲指定

```python
s = "A1a_!"
print(bool(re.fullmatch(r"[A-Za-z0-9_!]+", s)))  # → True
```

→ 英大文字・小文字・数字・アンダースコア・感嘆符のみで構成されているかを検査。

---

### 応用例②：日本語と記号の除外

```python
s = "こんにちは123"
pattern = r"[^\u3040-\u30FF\u4E00-\u9FFF]+"
print(re.findall(pattern, s))  # → ['123']
```

→ **ひらがな・カタカナ・漢字以外**の連続文字列を抽出しており、**非日本語部分の検出**が可能。

---

### 記号をそのまま書けるかの目安

| 記号  | エスケープ必要？  | 備考                     |
| --- | --------- | ---------------------- |
| `.` | 不要（`[]`内） | `.` は普通のドット扱い          |
| `-` | 要注意（範囲外で） | 範囲指定でなければ末尾で使うと安全      |
| `^` | 要注意（先頭で）  | 否定クラスになる（先頭以外なら通常）     |
| `]` | 必要        | `[]` の終端になるため `\]` が無難 |

---

### 注意点

* `[abc]` は `"a"` or `"b"` or `"c"` に一致するが、`(abc)` は `"abc"` という連続文字列に一致する
* `[^abc]` は `"a"` でも `"b"` でも `"c"` でもない**1文字**に一致する
* 空の文字クラス `[]` は無効でエラーになる

---

### 実務での用途

* **特定の文字種だけを許容するバリデーション**
* **記号や文字種を除外するフィルタリング処理**
* **英数字や記号の範囲を正確に制限する**
* **入力中に含まれてはいけない文字の検出（NGワード）**
* **日本語／英語／記号などの混在入力の分離・判定**

`[]` と `[^]` は、単体の文字に対する**ホワイトリスト・ブラックリスト的制御**を直感的に記述できる強力な構文であり、**入力制限や分類タスクに不可欠な機能**である。

---

## 18章：`|`（OR）とグルーピング `()`

---

### 解説

正規表現において `|` は「OR演算子（選択）」を意味し、**左右どちらかに一致すればマッチ**とする論理和の構文である。また、`()（グルーピング）` は、**複数文字列や構造をひとまとまりに扱うための構文**であり、`|` との併用によって**柔軟かつ複雑なパターン構築**が可能になる。

グループはさらに以下の用途を兼ねる：

* **部分マッチの抽出（キャプチャ）**
* **繰り返しや選択の範囲を制限**
* **名前付きグループ・非キャプチャなどの高度機能との併用**

この章では特に、「選択肢の明示」と「構造の制御」を軸に、`|` と `()` の組み合わせの強みを解説する。

---

### 基本使用例①：単語の選択マッチ

```python
import re

pattern = r"cat|dog|bird"
text = "I like cats, but I have a dog."

matches = re.findall(pattern, text)
print(matches)  # → ['dog']
```

→ `cat`, `dog`, `bird` のうち、いずれか1つに一致すればマッチする。`cats` は `cat` とは一致しないため抽出されない点に注意。

---

### 基本使用例②：グループで選択肢の境界を制御

```python
pattern = r"I have a (cat|dog|bird)"
text = "I have a cat"

m = re.search(pattern, text)
print(m.group(1))  # → cat
```

→ `()` によって選択肢の中身（cat/dog/bird）のみを\*\*キャプチャ（group(1)）\*\*できる。

---

### 応用例①：繰り返し対象をグルーピング

```python
pattern = r"(ha)+"
text = "hahaha!"

m = re.match(pattern, text)
print(m.group())  # → hahaha
```

→ `ha` のペアが繰り返される構造を、`(ha)+` によってひとまとまりに指定。**グループがなければ `a` のみ繰り返されることになる**。

---

### 応用例②：構文的な分岐の表現

```python
pattern = r"https?://(www\.)?(example|test)\.com"
text1 = "https://example.com"
text2 = "http://www.test.com"

print(bool(re.fullmatch(pattern, text1)))  # → True
print(bool(re.fullmatch(pattern, text2)))  # → True
```

→ 選択肢の中にさらにグループ（`www.`や複数ドメイン）が含まれており、**複雑な条件を組み合わせて柔軟なマッチを実現**している。

---

### 応用例③：条件付きの構造定義

```python
pattern = r"(?:(Mr|Ms)\. )?(Smith|Jones)"
text = "Ms. Smith"

m = re.match(pattern, text)
print(m.groups())  # → ('Ms', 'Smith')
```

→ `(?:...)` による非キャプチャグループと `|` による選択を組み合わせ、敬称が**あってもなくても良いが、存在するなら Ms または Mr に限る**という構造を定義。

---

### 応用例④：`|` の範囲を限定しないと誤爆するケース

```python
text = "gray or grey"
pattern = r"gr(a|e)y"

matches = re.findall(pattern, text)
print(matches)  # → ['a', 'e']
```

→ グループで範囲を制限して `a` または `e` のみを抽出可能。**単なる `gra|e` などでは「gra」か「e」になってしまい不正確**。

---

### グルーピングの種類と目的

| 構文              | 機能               | 備考                    |
| --------------- | ---------------- | --------------------- |
| `(pattern)`     | 通常のグループ（キャプチャあり） | `group(n)` で取得可能      |
| `(?:pattern)`   | 非キャプチャグループ       | 構造のみ使いたいときに有効         |
| `(?P<name>...)` | 名前付きキャプチャグループ    | `group('name')` で取得可能 |
| `(?=...)`       | 肯定先読み            | 条件だが消費しない             |
| `(?!...)`       | 否定先読み            | 否定条件                  |

---

### 注意点

* `|` は左から順に評価されるため、**長い方を先に書く**のが望ましい（早期マッチで終了）
* グループなしで `|` を使うと、**構文全体の範囲が曖昧になる**

  * 例：`abc|def` は `"abc"` または `"def"` に一致
  * だが、`ab(c|d)ef` は `"abcef"` または `"abdef"` に一致

---

### 実務での活用例

* **敬称・接頭語の選択**（Mr/Ms/Drなど）
* **複数のドメイン名・拡張子・ファイル種別の列挙**
* **複数エラーメッセージやコード種別の選択肢**
* **HTML/XMLタグやプレフィックスの柔軟処理**
* **言語や表記揺れに対応した入力の分岐処理**

`|` と `()` を適切に組み合わせることで、**選択肢と構造の両方を制御できる表現力の高い正規表現**を構築できる。入力の多様性を吸収しながら、処理の精度を損なわないための基本構文として必須である。

---

## 19章：エスケープ文字 `\` の役割

---

### 解説

`\`（バックスラッシュ）は、正規表現において**特殊文字を通常の文字として扱う（エスケープ）**ための記号である。同時に、`\d` や `\w` のように**特殊なシーケンス（エスケープシーケンス）を導入する記号**としても使われる。

つまり `\` は「特殊文字を無効化する」または「特殊な意味を付与する」ために使われ、文脈によって使い方が逆になる。そのため、Pythonの正規表現を記述する際には、**正規表現の構文とPythonの文字列構文の両方を理解した上で** `\` を二重で扱う必要があることも多い。

---

### 基本使用例①：特殊文字を通常の文字に変える

```python
import re

text = "file.name.txt"
pattern = r"file\.name\.txt"

print(bool(re.fullmatch(pattern, text)))  # → True
```

→ `.` は任意の1文字を意味する特殊文字だが、`\.` とすることで「リテラルのドット（.）」に限定できる。

---

### 基本使用例②：Python文字列リテラルにおける注意

```python
pattern = "\\d{3}"        # Python上では1つのバックスラッシュ
pattern_r = r"\d{3}"      # 推奨：raw文字列による明示的な正規表現

print(re.fullmatch(pattern_r, "123"))  # → <re.Match object>
```

→ Pythonの通常文字列では `\\` のように**バックスラッシュを2回書く必要がある**。`r"..."`（raw文字列）を使うと `\` をそのまま書けるため、正規表現では原則 `r""` を使用する。

---

### 応用例①：文字クラス内でのエスケープ

```python
pattern = r"[a\-z]"
print(bool(re.search(pattern, "a")))  # → True
print(bool(re.search(pattern, "-")))  # → True
```

→ 通常 `-` は範囲指定に使われるが、`\-` とすることで文字そのものとして扱える。

---

### 応用例②：パス文字列やバックスラッシュの扱い

```python
s = r"C:\Users\Public"
pattern = r"C:\\Users\\Public"
print(bool(re.fullmatch(pattern, s)))  # → True
```

→ バックスラッシュ自体を文字列に含めたい場合は `\\` のように二重に書く必要がある（Python文字列 → 正規表現）。

---

### よく使うエスケープ対象文字

| 記号      | 通常の意味     | エスケープ後の意味         |             |
| ------- | --------- | ----------------- | ----------- |
| `.`     | 任意の1文字    | リテラルのドット `\.`     |             |
| `*`     | 0回以上の繰り返し | `\*` → アスタリスク文字   |             |
| `+`     | 1回以上の繰り返し | `\+` → プラス記号      |             |
| `?`     | 0回または1回   | `\?` → クエスチョン     |             |
| `(` `)` | グループ指定    | `\(` `\)` → 括弧文字  |             |
| `[` `]` | 文字クラス定義   | `\[` `\]` → 角括弧文字 |             |
| `{` `}` | 回数制限構文    | `\{` `\}` → 中括弧   |             |
| \`      | \`        | OR                | `\|` → 縦棒文字 |
| `\`     | エスケープトークン | `\\` → バックスラッシュ   |             |

---

### 注意点

* エスケープミス（例：`\d.` のつもりで `d.` としてしまう）による意図しないマッチが非常に多い
* Pythonコード中の正規表現には**raw文字列 `r""` を原則として使用**する
* `\` は正規表現側とPython文字列側の**二重の構文上で作用する**ため、**構文エラーやパターン誤動作の主因になりやすい**

---

### 実務での用途

* **ファイル名やパス、拡張子の処理**
* **日付の区切り（`.`や`/`）の扱い**
* **ユーザー入力中の特殊記号を検出・サニタイズ**
* **SQL・HTMLなどの文法構造中の記号処理**
* **構文として使われている記号をデータとして扱う場面**

`\` の役割を正確に理解することは、**正規表現を安全に構築・運用するための前提条件**であり、初学者・熟練者問わず頻出のエラー源でもある。

---

## 20章：`re.escape()` による自動エスケープ

---

### 解説

`re.escape()` は、与えられた文字列中の**正規表現で特殊な意味を持つ記号をすべて自動的にエスケープ**するユーティリティ関数である。これにより、ユーザー入力や外部から取得した文字列を**安全に正規表現パターンに組み込む**ことが可能になる。

特に、「ユーザーが入力した検索語句をそのまま `re.search()` に使いたい」「ファイル名やURLなど、`.` や `+` を含む可能性のあるデータを正確に検出したい」などの場面で非常に有効である。

---

### 基本使用例①：ピリオド・括弧・疑問符などの自動エスケープ

```python
import re

raw = "file.name(ver.2)?"
escaped = re.escape(raw)
print(escaped)  # → file\.name\(ver\.2\)\?

pattern = re.compile(escaped)
print(bool(pattern.fullmatch("file.name(ver.2)?")))  # → True
```

→ 通常であれば一つずつエスケープしなければならない記号を、`re.escape()` 一発で処理できる。

---

### 応用例①：ユーザー入力による安全な部分一致検索

```python
user_input = "A+B"
escaped_input = re.escape(user_input)

text = "公式: A+B=C"
if re.search(escaped_input, text):
    print("見つかりました")  # → 見つかりました
```

→ `+` をエスケープしないと `"A+B"` の検索が「Aの後に1個以上のB」と誤認識される。`re.escape()` によって**意図通りのリテラル検索が可能**になる。

---

### 応用例②：辞書型テンプレートの安全な照合

```python
keywords = ["C++", "x*y", "(abc)", "1.23"]
compiled = [re.compile(re.escape(k)) for k in keywords]

text = "言語: C++ / 数式: x*y / 値: 1.23"

for p in compiled:
    m = p.search(text)
    if m:
        print("検出:", m.group())
```

→ ユーザー定義キーワードに `+`, `*`, `.`, `()` などが含まれていても、**正規表現的意味を持たせずにリテラル照合**ができる。

---

### エスケープ対象一覧

以下のような文字が自動的に `\` 付きに変換される：

| 記号       | 説明               |          |
| -------- | ---------------- | -------- |
| `.`      | 任意の1文字（→リテラルドット） |          |
| `*` `+`  | 繰り返し構文           |          |
| `?`      | オプション・非貪欲など      |          |
| `[]{}()` | グループ・文字クラス・量指定   |          |
| `^` `$`  | 行頭・行末アンカー        |          |
| `\`      | バックスラッシュそのもの     |          |
| \`       | \`               | 選択（OR）構文 |

---

### 注意点

* `re.escape()` はすべての特殊文字に対して `\` を付けるが、**意味のない文字にもエスケープを行う場合がある**（例：`/` など）
* `re.escape()` は文字列の**安全性重視**のため、意図的なパターン記述を含む文字列には不向き
* 「一部だけエスケープしたい」場合は手動操作が必要

---

### 実務での用途

* **ユーザー入力を検索条件に使う際の安全な正規表現生成**
* **ファイル名・タグ名・記号を含む識別子の検出**
* **テンプレートや辞書に基づく自動照合処理**
* **ログ・設定ファイル・コード内記号の正確なスキャン**

`re.escape()` を用いることで、**信頼できない入力や特殊文字を含む文字列を正規表現処理に安全に取り込むことができる**。これは正規表現のセキュリティ・安定性を確保する上で、非常に重要な補助手段である。

---