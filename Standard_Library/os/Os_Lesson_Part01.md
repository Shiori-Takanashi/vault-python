---
title: osモジュール01
keyword: os_module
created: 2025-07-29 21:05
modified: 2025-07-29 21:05
vault: Python
catergory: Language
language: Python
area: Standard_Library
identify:  
type: Lesson
tole: Part
order: 01
---

# 📢第01部：基礎ファイル操作

---

## 📍01章：`os` モジュールとは何か

---

### 📝解説

`os` モジュールは、Pythonが提供する標準ライブラリのひとつであり、**オペレーティングシステム（OS）とのインタフェースを抽象的に操作するための手段**を提供する。これにより、ファイルパス、環境変数、プロセス制御、ユーザー情報、ファイル操作などを、**OSに依存しない方法で実現**できる。

たとえば、同じ Python コードであっても、Windows・Linux・macOS のいずれでも同じように動作させたい場合、`os` モジュールを使用することで差異を吸収し、クロスプラットフォームなコードが書ける。また、後述する `pathlib` や `shutil`、`subprocess` などとも密接に関連しており、基盤的な役割を担っている。



### 📝利用範囲と導入

最も基本的な使い方は以下のように `import os` によってモジュールを読み込むことで始まる。

```python
import os

print(os.name)  # 'posix' あるいは 'nt'（OSの種類を示す）
```

このように、`os` モジュールの各関数は **OSのネイティブAPIをラップしたもの**であり、Pythonコードから直接OSリソースへアクセス可能になる。



### 📝主な機能カテゴリ

| カテゴリ          | 主な機能例                                          |
| - | - |
| ファイル・ディレクトリ操作 | `os.remove()` / `os.mkdir()` / `os.listdir()`  |
| パス処理          | `os.path.join()` / `basename()` / `splitext()` |
| 環境変数操作        | `os.environ` / `getenv()` / `putenv()`         |
| OS情報の取得       | `os.name` / `uname()` / `getlogin()`           |
| プロセス操作        | `os.system()` / `spawn*()` / `getpid()`        |
| 権限・ID情報       | `getuid()` / `geteuid()` / `getgid()`          |
| 実行ファイル情報      | `realpath(__file__)` によるスクリプト特定                |



### 📝`os` モジュールと他モジュールとの関係

* `shutil`：より高水準のファイル操作（コピー、移動、削除など）を提供
* `pathlib`：パス操作をオブジェクト指向で扱うモダンな代替手段
* `subprocess`：プロセス起動におけるより安全で柔軟な代替
* `tempfile`：一時ファイルの生成や削除に特化
* `sys`：終了処理や標準入出力制御など、一部重なる範囲あり



### 📝設計上の利点と限界

#### 利点

* **一貫性**：複数のOSで動作する共通のAPI
* **習得性**：UNIX・Windowsの知識があれば理解しやすい
* **汎用性**：スクリプトからシステムツールまで幅広く適用可能

#### 限界

* **古いAPIが多く残っている**：Python 3でも古典的な構文が現役
* **例外処理が煩雑**：明示的な例外対応が必要
* **モダンな構文との乖離**：`pathlib` のような可読性高い代替が登場している



### 📝学習上のポイント

* PythonでOS操作を扱うなら `os` モジュールの基本は避けて通れない。
* ただし、実践的な開発では `shutil` や `pathlib` などの後発モジュールと併用し、**適切に使い分けることが推奨される**。
* 単純なスクリプトやユーティリティツールでは `os` モジュール単体でも十分に対応可能である。

---

## 📍02章：OS情報の取得

---

### 📝解説

`os` モジュールを用いることで、実行中のPythonプロセスが稼働しているオペレーティングシステムに関する情報を取得できる。これは、環境に応じた動的な処理の分岐や、プラットフォーム固有の処理を回避する際に有用である。

たとえば、スクリプトがWindows上で動作しているのか、Linux上で動作しているのかを判定した上で、ファイルパスの区切りや一時ディレクトリの場所を正しく設定することができる。

---

### 📝主要関数と属性

| 機能                  | 説明                                                   |
| ------------------- | ---------------------------------------------------- |
| `os.name`           | 実行中OSの種類を文字列で返す。主に `'posix'`（UNIX系）と `'nt'`（Windows） |
| `os.uname()`        | UNIX系OSでのみ利用可能。システム情報（カーネル名・バージョン等）を返す               |
| `platform.system()` | 実行環境のOS名（例: "Windows", "Linux", "Darwin"）を返す         |
| `os.getlogin()`     | 現在のログインユーザー名を返す（端末経由の実行でないと失敗することがある）                |

`os.uname()` は POSIX準拠のOSに限定されるため、クロスプラットフォーム対応のコードを書く際は、Pythonの `platform` モジュールとの併用が推奨される。

---

### 📝使用例

```python
import os
import platform

print("OS種別（簡易）:", os.name)
print("OS種別（詳細）:", platform.system())

if os.name == 'posix':
    print("UNIX系OSです。")
elif os.name == 'nt':
    print("Windows系OSです。")
```

この例では、`os.name` によって大まかなOS種別を判定し、`platform.system()` によって具体的な名称を取得している。

---

### 📝実用的なユースケース

* WindowsとLinuxで異なるコマンドを実行したい場合
* OSに応じて設定ファイルの読み込み先やエンコード方式を切り替える場合
* ログファイルにホスト情報やシステムバージョンを記録するツールの開発

---

### 📝注意点と補足

* `os.getlogin()` は非対話的なシェルやGUI上で実行すると `OSError` を出すことがある。そのため `getpass.getuser()` の方が堅牢なケースもある。
* `os.uname()` はWindowsでは利用できないため、例外処理で補完するか、`platform.uname()` に置き換えることが望ましい。
* OSのバージョン情報やビルド番号など詳細を求める場合は `platform.version()` や `platform.release()` を併用する。

---
## 📍03章：環境変数の取得と操作

---

### 📝解説

Python の `os` モジュールは、実行環境に設定された環境変数を操作するためのインタフェースも提供している。環境変数は、システムやユーザーの設定・動作環境を外部から制御するための情報源であり、プログラムの設定値や実行動作を動的に変えるために頻繁に用いられる。

たとえば、認証トークンやAPIキー、ログ出力パスなどをソースコードにハードコーディングする代わりに、環境変数から読み込むことでセキュリティと柔軟性を両立できる。

---

### 📝主な機能

| 機能                            | 内容                                              |
| ----------------------------- | ----------------------------------------------- |
| `os.environ`                  | 環境変数を格納した辞書のようなオブジェクト。`os.environ["KEY"]` でアクセス |
| `os.getenv("KEY")`            | 指定キーの環境変数を取得（存在しない場合は `None` を返す）               |
| `os.putenv("KEY", "value")`   | 環境変数を設定（Python内部のみ。外部プロセスには影響しない場合がある）          |
| `os.environ["KEY"] = "value"` | 値の設定は辞書的操作の方が一般的であり、より安全に扱える                    |

---

### 📝使用例
このように `getenv()` で安全に取得し、存在チェックを挟むのが定石。設定は辞書的に操作すれば即時反映される。


```python
import os

# 環境変数の取得
token = os.getenv("API_TOKEN")
if token is None:
    print("トークンが設定されていません。")

# 設定（現在のプロセス内限定）
os.environ["MODE"] = "development"
print(os.environ["MODE"])  # → development
```


---

### 📝セキュリティと運用の注意点

* `os.environ` への書き込みは現在の Python プロセスのみに影響する。他のシェルや子プロセスに自動的には反映されないことに注意。
* 実行時に `.env` ファイルから環境変数を読み込む場合は `python-dotenv` などのライブラリを併用する。
* `print(os.environ)` のように全出力するのは、APIキーやパスワードを含む可能性があるため避ける。

---

### 📝実用場面

* デプロイ環境に応じた設定切り替え（例：開発用 vs 本番用）
* GitHub ActionsなどのCI/CDツールでの秘密情報注入
* Dockerコンテナにおける環境構成管理
* `.env` ファイルや `export` によるローカル設定の共有化

---

### 📝よくある誤解

* `putenv()` を使えば外部にも反映されると誤認されがちだが、実際は **Pythonプロセス内部の操作**に限られる。
* `os.getenv()` は辞書ではなく関数なので、キーが存在しないときに例外ではなく `None` を返す。この点が `os.environ["KEY"]` との明確な違い。

---
## 📍04章：カレントディレクトリの取得と変更

---

### 📝解説

スクリプトの実行中に、現在作業中のディレクトリ（カレントディレクトリ）を取得・変更したい場面は多い。Pythonの `os` モジュールでは、このカレントディレクトリの制御が `os.getcwd()` と `os.chdir(path)` を用いて容易に行える。

カレントディレクトリは、相対パスでのファイルアクセスの基準点となるため、**正しく把握・制御することがファイル処理の安定性と再現性に直結する**。一方、モジュール自身の物理配置パスとは異なるため、混同しないよう注意が必要である。

---

### 📝主な関数と特徴

| 関数名                         | 説明                                  |
| --------------------------- | ----------------------------------- |
| `os.getcwd()`               | 現在のカレントディレクトリ（絶対パス）を返す              |
| `os.chdir(path)`            | 指定したパスにカレントディレクトリを変更する              |
| `os.path.abspath()`         | 相対パスを絶対パスに変換する                      |
| `os.path.dirname(__file__)` | スクリプトファイル自身の配置ディレクトリを取得（モジュールの物理パス） |

---

### 📝使用例

```python
import os

# 現在のカレントディレクトリを取得
print("現在のディレクトリ:", os.getcwd())

# ディレクトリを変更
os.chdir("/tmp")
print("変更後のディレクトリ:", os.getcwd())
```

このコードでは、現在のディレクトリを `/tmp` に変更している。相対パスの解決基準がこの変更によって変わる点に注意。

---

### 📝モジュールパスとの違い

以下のコードで得られる2つのパスは異なる目的を持つ：

```python
import os

print(os.getcwd())               # 実行中のカレントディレクトリ
print(os.path.dirname(__file__))  # スクリプトファイルが存在するディレクトリ
```

`os.getcwd()` は実行時の作業ディレクトリ、`__file__` はスクリプトが配置されている物理ディレクトリを示す。たとえば、他のディレクトリから相対パスでスクリプトを実行した場合、この2つは一致しない。

---

### 📝よくあるユースケース

* 相対パスの基準を明示的に設定したいとき
* 実行前に特定ディレクトリへ移動してログ・出力ファイルを一元管理したいとき
* 設定ファイルやテンプレートファイルがスクリプトと同じ階層にある場合、その取得に `__file__` を使いたいとき

---

### 📝注意点

* `os.chdir()` を使うとプロセスのグローバル状態が変わるため、ライブラリ内部での使用は非推奨。
* パスは環境依存（Windows vs UNIX）なので、`os.path.join()` や `pathlib.Path` との併用が望ましい。
* `os.getcwd()` は常に絶対パスを返すが、スクリプト実行のコンテキストに依存するため、テスト環境では特に注意が必要。

---
## 📍05章：ファイル・ディレクトリの存在確認と作成

---

### 📝解説

ファイルやディレクトリを扱う際には、**事前にそれらの存在を確認し、必要に応じて安全に作成する処理**が不可欠である。Pythonの `os` モジュールは、こうした用途に対して `os.path.exists()` や `os.makedirs()` を含む複数の関数を提供しており、ディレクトリの有無や種類を判別したり、必要な階層を再帰的に作成することができる。

加えて、`os.path.isfile()` や `os.path.isdir()` を用いれば、対象がファイルかディレクトリかの判定も可能となる。

---

### 📝主な関数と用途

| 関数名                    | 説明                               |
| ---------------------- | -------------------------------- |
| `os.path.exists(path)` | 指定パスが存在するかどうかを真偽値で返す             |
| `os.path.isfile(path)` | 指定パスが「通常ファイル」かどうかを判定             |
| `os.path.isdir(path)`  | 指定パスが「ディレクトリ」かどうかを判定             |
| `os.makedirs(path)`    | 指定パスのディレクトリを再帰的に作成（親ディレクトリも自動作成） |
| `os.mkdir(path)`       | 単一ディレクトリの作成（親が存在しないとエラー）         |

---

### 📝使用例

```python
import os

path = "data/output"

# 存在確認と安全なディレクトリ作成
if not os.path.exists(path):
    os.makedirs(path)
```

このコードでは、`data/output` ディレクトリが存在しない場合に限り、再帰的に作成する処理を行っている。`makedirs()` は中間ディレクトリも含めて自動的に作成するため、階層が深い構造でも柔軟に対応できる。

---

### 📝ファイルとディレクトリの判別

```python
import os

target = "example.txt"

if os.path.isfile(target):
    print("通常ファイルです。")
elif os.path.isdir(target):
    print("ディレクトリです。")
else:
    print("存在しません。")
```

このように、パスの存在有無だけでなく、その種類を判定することで、適切な処理を分岐させることができる。

---

### 📝再帰的作成時の設計注意点

* `os.makedirs(path, exist_ok=True)` を用いれば、既に存在する場合にもエラーを発生させずに済む（Python 3.2以降）。
* 一時ディレクトリやログ出力先の準備など、**処理前に確実に存在させておきたい場面での安全処理**に有効。
* 書き込み先を動的に指定するCLIツールやWebアプリケーションでは、意図しないファイル操作を避けるため、存在確認と型判定は必須となる。

---

### 📝よくある誤用と対策

* `mkdir()` は単一階層しか作成できないため、親ディレクトリが存在しないと `FileNotFoundError` になる。複数階層を扱う場合は `makedirs()` を用いるべき。
* 存在確認 → 作成 の手順は競合状態（race condition）を生む可能性があるため、`exist_ok=True` の利用で原子的に処理するのが望ましい。
* ファイル名とディレクトリ名の衝突にも注意。存在確認は `isfile()`・`isdir()` で明示的に分類する。

---

## 📍06章：ファイルの削除・移動・名前変更

---

### 📝解説

ファイルやディレクトリの削除・移動・リネームといった操作は、ファイル管理処理の中核を成す機能であり、Pythonの `os` モジュールではこれらを直接制御するための関数が提供されている。特に `os.remove()`（または `unlink()`）による削除、`os.rename()` や `os.replace()` による移動・改名は、シンプルでありながら慎重な運用が求められる操作である。

ファイルの移動処理は、実際には「名前変更」または「別パスへの再配置」であり、OSによっては内部的に処理が異なる。これに対して、`shutil.move()` は `os.rename()` を内部的に使用しつつ、異なるデバイス間の移動にも対応している。

---

### 📝主な関数と比較

| 関数名                    | 機能                       | 備考               |
| ---------------------- | ------------------------ | ---------------- |
| `os.remove(path)`      | 指定ファイルを削除                | ファイル専用、存在しないと例外  |
| `os.unlink(path)`      | `remove()` の別名（UNIX系表現）  | 実質同一機能           |
| `os.rmdir(path)`       | 空のディレクトリを削除              | 中身があると `OSError` |
| `os.rename(src, dst)`  | ファイルまたはディレクトリの名前を変更または移動 | 移動先が存在すると上書き不可   |
| `os.replace(src, dst)` | 上書き可の安全な名前変更・移動          | `rename()` の上位互換 |

---

### 📝使用例

```python
import os

# ファイル削除
if os.path.exists("temp.txt"):
    os.remove("temp.txt")

# ファイル名変更
os.rename("old_name.txt", "new_name.txt")

# ファイル移動（同一ドライブ）
os.rename("data/file.txt", "archive/file.txt")
```

上記は、ファイルが存在する場合のみ削除し、その後ファイルをリネーム・移動する基本的な例である。

---

### 📝`shutil.move()` との違い

`os.rename()` や `os.replace()` は **同じデバイス上のファイル** に限定される。一方で `shutil.move()` は、別デバイス間の移動時に **コピー＆削除** のような内部処理を自動で行うため、より汎用的である。

```python
import shutil
shutil.move("source.txt", "/mnt/usb/backup.txt")
```

このコードでは、USBメモリなど他のマウントポイントにも安全に移動できる。

---

### 📝エラー処理と安全性の設計

* ファイルが存在しない場合 `remove()` は `FileNotFoundError` を発生させるため、事前の `os.path.exists()` チェックが有効。
* `rename()` は失敗しても例外が発生せずファイルが消えることはないが、競合状態の考慮は必要。
* `replace()` を使うことで既存ファイルへの上書きも安全に行えるが、データ損失防止のためバックアップ設計が望ましい。

---

### 📝よくあるミスと対処法

* ディレクトリを `os.remove()` で削除しようとすると `IsADirectoryError`。ディレクトリ削除には `os.rmdir()` または `shutil.rmtree()` を使う。
* 移動先のパスが存在しないと失敗するため、事前に `os.makedirs()` 等でディレクトリを作成しておく必要がある。
* 削除操作は取り消せないため、開発中は `print()` ログなどで対象を確認してから実行するのが安全。

---
## 📍07章：パス結合と正規化

---

### 📝解説

ファイルシステムのパス操作において、複数のパス要素を結合したり、冗長な表現を整理する「正規化」は非常に重要である。Pythonの `os.path` モジュールは、OSのパス区切り文字の違いを吸収しつつ安全にパスを組み立てる `os.path.join()` と、パス内の余分な `.` や `..` を解決して正規化する `os.path.normpath()` を提供している。

これらを活用することで、プラットフォームに依存せずに正確で可読性の高いパス操作が可能となる。

---

### 📝主な関数と役割

| 関数名                      | 機能説明                              |
| ------------------------ | --------------------------------- |
| `os.path.join(*paths)`   | 複数のパス要素をOS適合の区切り文字で結合し、正しいパスを生成   |
| `os.path.normpath(path)` | パス内の冗長部分（`.` や `..`）を解決し、簡潔なパスに変換 |
| `os.path.abspath(path)`  | 指定パスを絶対パスに変換（カレントディレクトリ基準）        |
| `os.path.realpath(path)` | シンボリックリンクを解決して実際のパスを返す（Unix系で有効）  |

---

### 📝使用例

```python
import os

# パス結合
dir_path = "/home/user"
file_name = "document.txt"
full_path = os.path.join(dir_path, file_name)
print(full_path)  # → /home/user/document.txt (Unix系の場合)

# 正規化
path = "/home/user/../user/docs/./file.txt"
normalized = os.path.normpath(path)
print(normalized)  # → /home/user/docs/file.txt

# 絶対パス取得
relative_path = "./docs/file.txt"
abs_path = os.path.abspath(relative_path)
print(abs_path)  # 実行環境に依存した絶対パスを返す
```

---

### 📝OS間の差異の吸収

* Windows ではパス区切りが `\`、Unix系は `/` だが、`os.path.join()` は自動的に適切な区切り文字を使用する。
* 手動で文字列連結するとクロスプラットフォームで誤動作するリスクが高まるため、常にこの関数を用いることが推奨される。

---

### 📝正規化の重要性

* パス中の `.`（カレントディレクトリ）や `..`（親ディレクトリ）を含むパスは、そのままだと不安定な動作や誤認識の原因となる。
* `normpath()` はそれらを解消し、ファイルシステム上の意味的に同一の簡潔なパスを返す。
* ただし、`normpath()` はパスの存在チェックはせず文字列処理のみであるため、ファイルの有無やアクセス権は別途確認が必要。

---

### 📝よくある誤解

* `abspath()` は必ず実在するパスを返すわけではなく、カレントディレクトリを基準に絶対パスの文字列を返すだけ。
* `realpath()` はシンボリックリンクの解決に使うが、Windows環境では制限があるため全環境で同様の動作を期待しないこと。

---

### 📝実用例

ファイルの保存先を動的に組み立てる際、例えば以下のように使う。

```python
import os

base_dir = os.path.expanduser("~/projects")
output_dir = os.path.join(base_dir, "output", "2025")
output_dir = os.path.normpath(output_dir)

if not os.path.exists(output_dir):
    os.makedirs(output_dir)
```

このコードはユーザーのホームディレクトリ配下に、年別の出力ディレクトリを安全に作成する一連の操作を示している。

---
