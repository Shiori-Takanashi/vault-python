# 📢Python-Threading-Lesson

---

## 📍第01部：スレッドの基礎理解

---

### 📝第01章_スレッドとプロセスの違い

* 並行処理の基本概念と構造の違い
* プロセスとスレッドの実行単位・メモリ構造
* スレッド共有とプロセス独立の利点・欠点

### 📝第02章_PythonにおけるGILの影響

* GIL（Global Interpreter Lock）の仕組み
* マルチスレッド処理における制限
* CPUバウンド vs I/Oバウンドの使い分け

### 📝第03章_`threading.Thread` の基本構文

* `Thread()` によるスレッドの生成
* `start()` による起動と `join()` による待機
* スレッドの基本的なライフサイクル

### 📝第04章_`target`, `args`, `kwargs` の使い方

* スレッドに関数と引数を渡す方法
* `args=()` / `kwargs={}` の使用構文
* 引数付き処理の汎用スレッド化

### 📝第05章_スレッドの `name` と `ident` の活用

* スレッド名の明示的な指定
* `ident` による一意な識別
* ログ・デバッグにおける活用事例

### 📝第06章_`current_thread()` / `main_thread()` の使い方

* 現在のスレッド取得と比較
* メインスレッドとの識別方法
* 条件分岐や制御判定への応用

### 📝第07章_サブクラスによるスレッド定義

* `Thread` の継承と `run()` の実装
* カスタムクラスとしてのスレッド設計
* 属性や状態を保持するスレッド構造

### 📝第08章_`start()` と `join()` の内部動作

* 非同期実行の開始タイミング
* `join()` による同期ポイントの確立
* スレッド間の依存関係設計

### 📝第09章_`is_alive()` とスレッドの状態管理

* 実行中スレッドの状態取得
* 状態による制御・判定処理
* 複数スレッドの監視と同期設計

---

## 📍第02部：ロックと同期の基礎

---

### 📝第10章_データ競合とレースコンディション

* 複数スレッドによる同時書き込みの危険性
* 読み書きのタイミングずれと状態破壊
* 保護されていないリソースの設計リスク

### 📝第11章_`Lock` の基本構文と注意点

* `Lock()` による単純な排他制御
* `acquire()` / `release()` の明示的操作
* ロックの取り忘れとクラッシュの危険

### 📝第12章_`with Lock` によるコンテキスト管理

* `with` によるロック自動管理
* 明示的 vs 暗黙的なロック制御の比較
* エラー時にも安全にロック解放する方法

### 📝第13章_例外安全性とロック設計

* `try` / `finally` による明示的保護
* `with` を使うことで例外耐性を強化
* ロジックとロックの分離方針

### 📝第14章_`RLock`（再帰ロック）の必要性

* 同一スレッドによる多重ロック取得の対処
* `Lock` との構造的な違いと設計用途
* 再帰的な関数呼び出し時の安全性確保

### 📝第15章_複数ロックとデッドロック

* 複数ロックの取得順序によるデッドロック例
* デッドロックの再現と観察
* 排他設計における回避パターン

### 📝第16章_ロック処理の関数分離

* ロック取得を関数外で行う設計
* 処理関数に副作用を持たせない方針
* テスト容易性・責任分離の向上

### 📝第17章_`locked()` によるロック状態確認

* ロックが現在取得済みかを確認するAPI
* 条件付き取得・再試行制御の設計
* ロック状態によるフロー分岐

### 📝第18章_ロックと共有変数の設計方針

* グローバル変数に依存しない設計
* スレッドごとの状態分離と排他のバランス
* ロック範囲の最小化による副作用の抑制

---

## 📍第03部：状態管理・フロー制御

---

### 📝第19章_`Event` によるシグナル制御

* `set()` / `clear()` / `wait()` の基本動作
* スレッド間でのフラグ共有と信号制御
* 単純な一時停止・再開処理への応用

### 📝第20章_タイムアウト付きのイベント待機

* `wait(timeout=秒数)` による一時的待機
* 非同期的な監視・解除設計の導入
* 長時間ブロック回避の設計原則

### 📝第21章_`Condition` による条件通知の基本

* `wait()` / `notify()` の使い分け
* 明示的な状態依存の制御設計
* 複数待機スレッドへの制御パターン

### 📝第22章_`Condition` と `Lock` の内部構造

* 条件変数が内部でロックと連動する仕組み
* `acquire()` との関係と制御責任の分離
* 使用時に注意すべき前提条件

### 📝第23章_スレッド順序の制御実装

* `Condition` による順序付きタスク処理
* 明示的な順序保証と待機制御の設計
* キューなどとの併用パターンの検討

### 📝第24章_`Semaphore` と `BoundedSemaphore`

* 同時アクセス数を制限する目的と意義
* `BoundedSemaphore` による上限違反の検出
* サーバ接続やリソース割当の制御設計

### 📝第25章_`Barrier` によるスレッド合流制御

* 指定数スレッドの同期ポイントの設計
* `wait()` による再開タイミングの統一
* 複数段階のステージ分岐に対する応用

### 📝第26章_`Timer` を用いた遅延スレッド起動

* 一定時間後に非同期的に処理を実行する構文
* タイマーのキャンセルと再設定の設計考慮
* 定期実行用途への誤用とその問題点

### 📝第27章_イベントによる実行状態の保持と制御

* `Event` を使った再開条件の持続制御
* 状態管理フラグとしての運用パターン
* スレッド間でのシンプルな制御契約の構築

---

## 📍第04部：管理・設計・運用

---

### 📝第28章_デーモンスレッドの定義と意味

* `daemon=True` / `setDaemon(True)` の使い方
* メインスレッド終了と自動停止の関係
* デーモンスレッドの適切な利用場面

### 📝第29章_`join()` とデーモン属性の関係性

* `join()` の有無による待機制御の違い
* デーモンフラグと `join()` の組み合わせでの挙動比較
* 強制終了回避の設計ポイント

### 📝第30章_巻き添え停止による設計上のリスク

* `daemon=True` による未完了処理の中断
* 外部リソース（ファイル・DB）使用時の危険性
* 後処理・例外通知の保証設計

### 📝第31章_プロデューサー／コンシューマモデル

* `queue.Queue` を用いた安全な通信構造
* `put()` / `get()` のスレッド安全性
* 複数スレッドの分業化による設計効率

### 📝第32章_`Queue` を使ったタスク制御

* `task_done()` / `join()` による完了待機制御
* 処理の進行・停止を `Queue` 側で監視する設計
* キュー詰まりや未完了処理の検出

### 📝第33章_スレッド例外の処理と通知設計

* スレッド内 `try-except` 構造の必須性
* ログへの記録、親スレッドへの伝播方法
* UIスレッドとの連携における例外報告

### 📝第34章_複数スレッドの一括管理クラス

* スレッド群の生成・開始・監視・停止の統括設計
* スレッドリストと個体識別による制御構造
* 管理責任の集中と設計上のテスト性向上

### 📝第35章_スレッド強制終了問題とその回避

* Pythonが `kill()` 相当を持たない理由
* フラグ・状態チェックによる自発的終了設計
* 中断可能性と非同期設計原則の両立

### 📝第36章_`asyncio` との使い分けと整理

* `threading` と `asyncio` の対象領域の違い
* I/O待ち・並列性・CPUバウンド処理の切り分け
* モジュール選定の指針と設計原則のまとめ

---