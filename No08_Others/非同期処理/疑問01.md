# ❓質問
> なぜawaitする必要がある？gatherした結果を使わないのに。

# ❗回答
> その問いは本質的です。
> 「`await` する理由がないように見える」状況は、特に**副作用（ファイル保存やログ出力など）だけを目的とする非同期処理**でよく起こります。
> 結論から言えば：

> `await` をしないと **タスクは実行されません**。
> gather の結果を使わなくても、**非同期処理を開始するために await が必要**です。

---

## ✅ なぜ `await` が必要か（gather 編）

### 例：

```python
tasks = [do_something_async(i) for i in range(10)]
# asyncio.run() だけでは何も起きない
```

→ `tasks` はただの**coroutineオブジェクトのリスト**であり、**実行はされていない**。

```python
await asyncio.gather(*tasks)
```

→ ここで **イベントループに登録され、初めて実行される**。

---

## ✅ gather の結果を「使わない」のは問題か？

### → 問題ではない

```python
await asyncio.gather(*tasks)  # 結果を捨てるだけ
```

これは「並列実行させて完了を待つ」ために使われます。
**結果を使わない = 副作用の完了を待っている**だけです。

---

## ✅ `await` を忘れたらどうなるか

* `fetch_and_write(...)` を `create_task()` せず `await` もしない → **何も実行されない**
* `async def` を呼び出しただけ → **coroutineオブジェクトが生成されるだけで放置される**
* `gather()` を `await` せずに呼んでも → **コルーチンを生成するだけ**

結果として：

> **`await` をしない = 非同期処理が「スケジュールされない」= 実行されない**

---

## ✅ 補足：本当に非同期処理に「意味がない」なら？

* 順番に1件ずつやっても良い → `for idx in ...:` に `await` を直接書けばいい
* だが現実には、60並列などで**速度向上が見込まれるため非同期化している**
* したがって、「結果を使わなくても `await` は必要」

---

## ✅ 結論

> `await` は「結果を得るため」だけでなく、「**非同期処理をイベントループに登録し、実行を保証するため**」に必須です。
> gatherの戻り値を使わなくても、`await` しなければ**その非同期処理はそもそも始まりません**。

この仕組みが分かれば、Django ORMの中で `async def` がどう使われているか（例：`await session.execute(...)`）の理解も本質的に近づいていきます。
