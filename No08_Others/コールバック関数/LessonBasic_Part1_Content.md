# 基礎知識

---

## 1章: コールバック関数とは何か

---

### 解説

コールバック関数とは、他の関数に引数として渡される関数のことである。Pythonでは関数が「第一級オブジェクト」として扱われるため、変数に代入したり、引数として渡すことができる。この性質を活かすことで、処理の一部を外部から差し替える柔軟な設計が可能になる。

たとえば、`sorted()` 関数において `key` 引数に比較関数を指定することで、並び替え基準を自由に変更できる。これは「比較方法」という処理を呼び出し元が自由に差し込める構造であり、典型的なコールバックの利用例である。

このような構造はGUIや非同期処理、イベントドリブン設計などでも多用される。処理の委譲によって柔軟性と拡張性を高めるのがコールバック関数の主な目的である。

---

### 他言語における比較

| 言語         | コールバックの記述例                            | 特徴               |
| ---------- | ------------------------------------- | ---------------- |
| JavaScript | `setTimeout(() => {...}, 1000)`       | 非同期・イベント処理が中心    |
| C          | `void f(void (*cb)(int)) { cb(42); }` | 関数ポインタを明示的に扱う    |
| Java       | `interface Callback { void call(); }` | インターフェースによる明示的設計 |
| Python     | `def f(cb): cb()`                     | 関数がそのまま引数として渡せる  |

---

### コード例（基本）

```python
def notify(callback):
    print("開始")
    callback()
    print("終了")

def greet():
    print("こんにちは")

notify(greet)
```

この例では `notify()` 関数が前後処理を行い、中央の動作（`greet()`）はコールバックとして外部から渡されている。このように、処理の一部を差し替える柔軟性が得られる。

---

### コールバックの利点と用途

| 項目      | 内容                              |
| ------- | ------------------------------- |
| 処理の切替自由 | 関数を差し替えることで異なる動作を柔軟に実行できる       |
| 再利用性    | 汎用ロジックと具体的処理を分離でき、再利用しやすい       |
| 構造の明確化  | 明示的な関数渡しにより「どこで何が実行されるか」を把握しやすい |
| イベント対応  | 状態変化や外部入力に応じた動的処理切り替えに対応しやすい    |
| テスト容易性  | モック関数やスタブを用いて局所的な動作検証が可能        |

---

### 注意点

* `callback` に `()` を付けて渡すと「実行された結果」が渡ってしまう。関数そのものを渡す場合は括弧をつけない。
* コールバックを多用しすぎると、ネストや処理追跡の負担が増す（いわゆる「コールバック地獄」）。
* 引数として渡す関数が副作用を持つ場合、再利用やデバッグの難易度が上がる。

---

### 用語と構造の整理

| 用語       | 定義内容                              |
| -------- | --------------------------------- |
| 第一級関数    | 関数を値のように扱える性質（変数代入・引数・戻り値として使用可能） |
| コールバック関数 | 引数として他の関数に渡される実行対象関数              |
| 高階関数     | 関数を受け取る、または関数を返す関数                |

---

### 代表的な活用例

| 使用箇所                     | コールバック用途           |
| ------------------------ | ------------------ |
| `sorted(key=func)`       | 比較基準のカスタマイズ        |
| `map(func, iterable)`    | 要素ごとの一括処理          |
| GUI（`button(command=f)`） | ボタン押下時の処理定義        |
| `asyncio.call_soon(f)`   | 非同期イベントループへの遅延処理登録 |

---

### 学習ポイントの要約

* Pythonでは関数を引数として渡すことで処理を外部から注入できる。
* 柔軟性・拡張性・再利用性を高めるための基本手段。
* 処理の構造化と分離を進める設計パターンとして重要である。

---
## 2章: 関数を引数として渡す構文

---

### 解説

Pythonでは、関数を他の関数の引数として渡すことができる。この性質は「第一級関数」によって実現されており、関数そのものがオブジェクトとして扱われるためである。

関数を渡す際に重要なのは、関数名そのもの（例：`func`）と、関数の実行結果（例：`func()`）を区別することである。前者は関数の参照を渡すことを意味し、後者は関数を即時実行してその戻り値を渡すという意味になる。

コールバックを正しく機能させるには、関数を「実行せずにそのまま渡す」ことが前提である。また、受け取る側の関数はその引数が「関数」であると意識して設計する必要がある。

---

### 基本構文と挙動の違い

```python
def call_func(func):
    print("前処理")
    func()
    print("後処理")

def hello():
    print("こんにちは")

# 正しい使用
call_func(hello)

# 誤った使用（hello()の戻り値 None を渡してしまう）
call_func(hello())
```

上記のうち、下の `call_func(hello())` は `hello()` が即時実行され、その結果（`None`）が `call_func` に渡ってしまうため、意図した動作にはならない。

---

### コールバックの呼び出しタイミング

関数を引数として渡すことで、呼び出しのタイミングを制御できる。たとえば、ある関数の実行前後に共通の処理を挟むような構造において、実際の動作タイミングは呼び出し側ではなく、受け取った関数の中で決定される。

```python
def delay_run(func):
    print("まだ呼び出さない")
    # 条件を満たしたときだけ呼び出す
    if True:
        func()
```

このように、引数として渡された関数は、受け手の判断で好きなタイミングに実行できる。

---

### 処理の遅延と副作用の制御

関数を「実行せずに渡す」ことで処理を遅延させる設計は、以下のような状況で有効である。

| 状況             | 効果                               |
| -------------- | -------------------------------- |
| 実行条件が外部依存      | 条件を満たすときだけ関数を実行する構造が作れる          |
| 再実行・リトライの必要がある | 同じ関数を何度も安全に呼び出せる                 |
| 副作用を管理したい      | 関数実行のタイミングを制御することで、意図しない変更を避けられる |

---

### 注意点

* コールバック対象の関数に引数が必要な場合、呼び出し側もその引数の提供を考慮する必要がある。
* 関数の実行を制御する設計では、例外処理や実行可否の条件も合わせて組み込むのが望ましい。
* 関数を `()` 付きで渡してしまうミスは、初心者が頻繁に陥る誤りである。

---

### 発展例：関数に引数を渡す

```python
def call_with_args(func, *args, **kwargs):
    print("処理開始")
    func(*args, **kwargs)
    print("処理終了")

def greet(name, lang="ja"):
    if lang == "ja":
        print(f"{name}さん、こんにちは")
    else:
        print(f"Hello, {name}!")

call_with_args(greet, "田中")
call_with_args(greet, "John", lang="en")
```

このように `*args` や `**kwargs` を用いれば、柔軟に任意の関数に引数を渡すことが可能になる。

---

### 用語と構造の整理

| 用語         | 内容                                   |
| ---------- | ------------------------------------ |
| 関数の参照      | `func` のように、実行せずに関数をそのまま扱うこと         |
| 関数の実行      | `func()` のように、関数を即時に実行する構文           |
| 遅延実行       | 渡された関数を、後から任意のタイミングで実行する設計           |
| 引数付きコールバック | `func(*args, **kwargs)` による汎用的な呼び出し方 |

---

### 代表的な活用例

| 使用ケース                | 内容                    |
| -------------------- | --------------------- |
| `retry(func)`        | 処理の失敗時に関数を再実行する       |
| `schedule(func)`     | タスクスケジューラに処理を登録する     |
| `atexit.register(f)` | プログラム終了時に関数を呼び出す構文    |
| `button(command=f)`  | GUIイベントで関数をボタンに登録する構文 |

---
## 3章: lambdaによるコールバック簡略化

---

### 解説

Pythonでは `lambda` 式を用いることで、関数定義を省略して簡易的な関数を作成できる。これは関数を一時的に作成して、その場でコールバックとして渡したい場合に有効である。

特に、簡単な処理をコールバックにしたいとき、`def` で関数を定義するのは冗長であるため、`lambda` によってコード量を減らすことができる。ただし、`lambda` は1行しか書けず、複雑な処理には向かない。

---

### 基本例：lambdaでの書き換え

```python
def apply(func):
    result = func(10)
    print(f"結果: {result}")

# 通常の関数を渡す場合
def square(x):
    return x * x

apply(square)

# lambdaで書き換えた場合
apply(lambda x: x * x)
```

このように、簡易な処理を一時的に使いたい場面では `lambda` を使うとコードの行数を減らせる。

---

### lambdaの構文と制約

| 特徴       | 内容                                |
| -------- | --------------------------------- |
| 無名関数     | 名前を持たず、その場限りで使い捨てられる              |
| 単一式制限    | `:` の右側に式を1つしか書けない                |
| return不要 | 暗黙的にその式の値が返る（明示的な `return` は書けない） |
| 複雑処理不可   | 条件分岐、複数行処理、ループなどは書けない             |

---

### 使用上の判断基準

| 適している場面              | 避けるべき場面             |
| -------------------- | ------------------- |
| 単純な計算・変換処理           | 複雑な処理や副作用を含む関数の定義   |
| 一時的・短命な関数定義          | 複数箇所で再利用される処理       |
| 高階関数への渡し（`map`, etc） | コールバックが複雑で可読性が重要な場面 |

---

### 注意点

* `lambda` に名前をつけるべきか悩む場面では、そもそも `def` を使うべきか再検討すべき。
* `lambda` でネストされた処理を書くと可読性が著しく低下する。
* 複数のパラメータが必要なときには、位置引数・キーワード引数の扱いに注意が必要。

---

### コード例：sortのkey引数での活用

```python
data = ["banana", "apple", "cherry"]
sorted_data = sorted(data, key=lambda x: len(x))
print(sorted_data)  # ['apple', 'banana', 'cherry']
```

このように `lambda` は「その場で定義する小さな関数」として key や filter 条件などによく使われる。

---

### コード例：複雑な処理に不適な例

```python
# 読みにくい例
process = lambda x: x**2 if x > 0 else -x + 1 if x < 0 else 0
```

このような書き方は構文的には可能だが、可読性が低いため `def` による明示的な定義が望ましい。

---

### 用語と構造の整理

| 用語      | 内容                               |
| ------- | -------------------------------- |
| lambda式 | 無名の関数を作る構文。短い式にのみ使用可能。           |
| 高階関数    | 関数を受け取る関数。`lambda` の主な渡し先。       |
| key関数   | ソート時に基準を指定する関数。`lambda` がよく使われる。 |

---

### 代表的な活用例

| 使用箇所                    | lambda活用内容                    |
| ----------------------- | ----------------------------- |
| `sorted(key=...)`       | 並び替え基準をその場で記述                 |
| `map(lambda x: ...)`    | イテラブルの各要素を変換                  |
| `filter(lambda x: ...)` | 条件に合う要素を抽出                    |
| GUIイベント処理               | `command=lambda: 処理()` のような登録 |

---
## 4章: 関数を返す関数

---

### 解説

Pythonでは関数の戻り値として、別の関数を返すことができる。これも「第一級関数」の性質によるものであり、処理を動的に生成したり、状態を内包した関数を作成する際に使われる。

このような関数の中に関数を定義する構造を「クロージャ」と呼ぶ。クロージャでは、外側のスコープの変数を内側の関数が保持し続けるため、状態を持った関数オブジェクトのように振る舞うことができる。

---

### 基本構文：関数を返す関数

```python
def outer():
    def inner():
        print("内側の関数が実行されました")
    return inner

f = outer()
f()  # => 内側の関数が実行されました
```

この構文では `outer()` を実行すると `inner()` を返し、その返された関数を後から実行している。

---

### クロージャと状態の保持

クロージャを使うことで、関数に値や状態を「閉じ込めた」関数を生成することができる。

```python
def greeter(name):
    def say_hello():
        print(f"{name}さん、こんにちは")
    return say_hello

f1 = greeter("田中")
f2 = greeter("佐藤")

f1()  # => 田中さん、こんにちは
f2()  # => 佐藤さん、こんにちは
```

ここで `name` は `say_hello()` のスコープ外の変数だが、クロージャによって維持されている。

---

### 状態を持ったコールバックとしての利用

クロージャを用いることで、呼び出されるたびに異なる結果を返すような、状態付きの関数を作ることができる。

```python
def counter():
    count = 0
    def increment():
        nonlocal count
        count += 1
        return count
    return increment

c = counter()
print(c())  # => 1
print(c())  # => 2
```

このように、`nonlocal` を使えば外側のローカル変数を内部で更新できる。

---

### 用途と利点

| 利点          | 内容                           |
| ----------- | ---------------------------- |
| 状態保持        | 外部変数を保持して関数に組み込める            |
| カプセル化       | 内部実装を隠蔽しつつ、外部に必要な機能だけを公開できる  |
| ファクトリ的設計    | 特定の構成をもった関数を生成し、再利用しやすくなる    |
| 柔軟なコールバック構築 | 状態やパラメータに応じて動作が変わるコールバックが作れる |

---

### 注意点

* 関数が返されるだけで実行されていないことに注意する。
* 関数を返す構文を多用すると可読性が低下する場合があるため、適切に構造を整理する必要がある。
* `nonlocal` の使いどころを誤ると、状態の追跡が難しくなることがある。

---

### 構造と定義整理

| 構造             | 説明                          |
| -------------- | --------------------------- |
| `def outer():` | 外部関数。設定・状態を含む               |
| `def inner():` | 内部関数。実際の処理ロジックを持つ           |
| `return inner` | 外部関数の戻り値として内部関数を返す          |
| `nonlocal`     | 外部関数のローカル変数を内部関数から操作するために必要 |

---

### 活用例

| 使用場面           | 内容                               |
| -------------- | -------------------------------- |
| コールバックに状態を持たせる | 条件によって動作を変えるコールバック関数を生成          |
| デコレータの構造       | 関数を返す関数として `@decorator` を実現する    |
| パラメータ付き処理生成    | `make_multiplier(2)` → 2倍関数の生成など |
| 一時的な状態記憶       | 関数を通じて設定を閉じ込めて保持する               |

---
