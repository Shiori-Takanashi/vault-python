## 5章: 標準ライブラリに見るコールバック

---

### 解説

Pythonの標準ライブラリでは、コールバック関数を受け取る構造が多数存在している。これにより、処理の一部をユーザーが指定できる柔軟なAPI設計が実現されている。典型的な例としては、`sorted()`、`map()`、`filter()`、`reduce()` などの高階関数がある。

これらは、ユーザーから関数を引数として受け取り、それを内部で適切なタイミング・形式で実行する。つまり、ユーザー定義の処理を「いつ」「どのように」呼び出すかをフレームワーク側が制御し、利用者は処理内容にのみ集中できる。

---

### `sorted()` の `key` 引数

```python
data = ["banana", "apple", "cherry"]
result = sorted(data, key=lambda x: len(x))
print(result)  # ['apple', 'banana', 'cherry']
```

この例では `key` 引数に関数を渡すことで、ソートの基準を外部から指定できている。これは典型的な「委譲による柔軟性」の実現である。

---

### `map()` と `filter()` による関数適用

```python
nums = [1, 2, 3, 4, 5]

# mapで2乗する
squares = list(map(lambda x: x * x, nums))

# filterで偶数だけ取り出す
evens = list(filter(lambda x: x % 2 == 0, nums))

print(squares)  # [1, 4, 9, 16, 25]
print(evens)    # [2, 4]
```

これらはイテラブルなデータに対し、関数ベースで変換や抽出を行う構文である。渡す関数は一時的な処理でもよく、`lambda` と相性が良い。

---

### `functools.reduce()` による累積処理

```python
from functools import reduce

total = reduce(lambda x, y: x + y, [1, 2, 3, 4])
print(total)  # 10
```

ここでは最初の2つの要素を処理し、結果を次の要素に対して再適用する形で処理が進む。コールバック関数は「累積演算子」として使われている。

---

### 標準ライブラリにおけるコールバックの主な特徴

| 関数                       | コールバックの役割 | 呼び出されるタイミング      |
| ------------------------ | --------- | ---------------- |
| `sorted(key=func)`       | 並び替え基準の指定 | 各要素に適用され、ソート時に使用 |
| `map(func, iterable)`    | 要素変換処理    | 各要素に対して逐次的に呼び出し  |
| `filter(func, iterable)` | 抽出条件の判定関数 | 各要素に適用し、Trueで残す  |
| `reduce(func, seq)`      | 累積演算処理    | 前回の結果と次の要素に適用    |

---

### 活用上の注意点

* コールバック関数の定義が複雑になると、処理内容が追いにくくなる。
* 可読性が落ちる場合には `lambda` を避けて、名前付き関数を定義する方が良い。
* コールバックに副作用を含めると、関数本来の意図（変換・選別・比較など）から逸脱する可能性がある。

---

### 用語と構造の整理

| 用語       | 内容                          |
| -------- | --------------------------- |
| 高階関数     | 関数を引数に取る、または返す関数            |
| コールバック   | 利用者が定義し、呼び出し元が実行する処理関数      |
| `key` 関数 | 要素のソートや抽出の際に、評価基準を提供するための関数 |

---

### 利用シーンまとめ

| シーン           | 利点                              |
| ------------- | ------------------------------- |
| データ処理         | map/filter/reduceでイテラブルを関数で加工可能 |
| ソート処理         | key関数で柔軟な並び替えが可能                |
| API/フレームワーク拡張 | 処理を外部関数で差し込むことで機能追加が容易          |

---
## 6章: ユーザー定義関数での適用

---

### 解説

Pythonでは、コールバックを受け取る関数を自作することも簡単である。これにより、処理の一部を外部に委譲しつつ、ユーザーが柔軟に動作を差し替えられる汎用的な関数設計が可能になる。

関数の引数として他の関数（＝コールバック）を受け取り、必要なタイミングでその関数を呼び出すという構造を意識的に取り入れることで、設計の柔軟性と再利用性が向上する。

---

### 基本構文：コールバックを受け取る関数

```python
def run_twice(callback):
    callback()
    callback()

def greet():
    print("こんにちは")

run_twice(greet)
```

この例では `run_twice()` がコールバック `greet` を2回呼び出す。呼び出し側は処理内容を差し込むだけで、共通の流れ（2回呼び出す）は `run_twice()` 側が保持している。

---

### 引数つきのコールバック関数を扱う

```python
def apply_to_list(func, data):
    return [func(x) for x in data]

def square(x):
    return x * x

print(apply_to_list(square, [1, 2, 3]))  # [1, 4, 9]
```

引数を受け取る関数も、通常の引数と同じように扱える。ここでは `func(x)` の形式で各要素に処理を適用している。

---

### `Callable` による型ヒントの導入

関数型引数に型ヒントを付けることで、静的解析やエディタ補完の精度を向上させることができる。

```python
from typing import Callable

def run_task(task: Callable[[], None]) -> None:
    task()
```

この例では、引数 `task` は「引数なし・戻り値なしの関数」であると明示されている。

---

### 可変長引数との併用

```python
from typing import Callable, Any

def execute(func: Callable[..., Any], *args, **kwargs):
    return func(*args, **kwargs)

def add(x, y):
    return x + y

print(execute(add, 3, 5))  # 8
```

`Callable[..., Any]` によって、任意の引数を受け取る関数にも柔軟に対応できる。このように設計すると、汎用的な関数呼び出しラッパーが作れる。

---

### コールバックをリストや辞書で管理する

複数の関数を切り替えて実行する場合、コールバック関数をリストや辞書に保持しておくと便利である。

```python
def hello(): print("Hello")
def bye(): print("Goodbye")

callbacks = [hello, bye]
for cb in callbacks:
    cb()

named = {"greet": hello, "exit": bye}
named["greet"]()  # Hello
```

関数は変数のように扱えるため、構造体やコンテナにまとめることで切り替えや選択が簡単になる。

---

### 用語と構造の整理

| 概念        | 内容                              |
| --------- | ------------------------------- |
| コールバック引数  | ユーザー定義関数で関数を受け取る引数              |
| Callable型 | 関数型であることを型ヒントとして明示              |
| 可変長引数     | `*args`, `**kwargs` により任意の引数に対応 |
| コレクション管理  | 関数を複数まとめて切り替え可能にする手法            |

---

### 実用パターン

| パターン         | 内容                        |
| ------------ | ------------------------- |
| データ変換関数の差し替え | 複数の変換関数を渡して処理を分岐させる       |
| 登録型処理の実装     | 関数を辞書に登録してコマンドのように実行可能にする |
| 設定に応じた処理切り替え | 引数や設定値に応じて呼び出す関数を選択       |

---
## 7章: イベント駆動設計におけるコールバック

---

### 解説

イベント駆動設計では、「ある出来事（イベント）が発生したときに、それに対応した処理を実行する」という構造が中心になる。コールバック関数はこの仕組みにおいて非常に重要な役割を果たす。なぜなら、どの処理を実行するかを、イベント発生時まで「遅延」して指定できるからである。

GUIプログラミングやリアクティブシステム、非同期IOなど、イベントが中心となる領域では、処理を事前に登録しておき、イベント発生時に呼び出す方式（＝コールバック登録）が広く採用されている。

---

### GUIライブラリでの典型例（Tkinter）

```python
import tkinter as tk

def on_click():
    print("ボタンが押されました")

root = tk.Tk()
button = tk.Button(root, text="Click Me", command=on_click)
button.pack()
root.mainloop()
```

この例では、ボタンがクリックされたときに `on_click()` 関数が呼ばれるように `command` 引数として登録している。

---

### 状態に応じたコールバックの切り替え

コールバック関数を切り替えることで、同じイベントに対して異なる反応を持たせることができる。

```python
def on_success():
    print("成功処理")

def on_failure():
    print("失敗処理")

def handle_event(success: bool, callback_success, callback_failure):
    if success:
        callback_success()
    else:
        callback_failure()

handle_event(True, on_success, on_failure)   # => 成功処理
handle_event(False, on_success, on_failure)  # => 失敗処理
```

このようにイベントの状態によって関数を選択して実行できるのも、コールバック構造の利点である。

---

### 複数イベントの分離設計

複数の種類のイベントが存在する場合、それぞれのイベントに対して個別の関数を登録し、分離して管理することで構造が明確になる。

```python
event_handlers = {}

def register_event(name, handler):
    event_handlers[name] = handler

def trigger_event(name):
    if name in event_handlers:
        event_handlers[name]()

register_event("login", lambda: print("ログイン完了"))
register_event("logout", lambda: print("ログアウト完了"))

trigger_event("login")   # => ログイン完了
trigger_event("logout")  # => ログアウト完了
```

イベント名と処理の対応を辞書で管理することで、柔軟かつ明確にコールバックを運用できる。

---

### 用語と構造の整理

| 概念       | 内容                         |
| -------- | -------------------------- |
| イベント駆動設計 | 処理の起点が「イベントの発生」によって決まる構造   |
| コールバック登録 | イベントに対応する関数を事前に登録しておく操作    |
| イベントハンドラ | 実際にイベントが発生したときに呼び出される関数    |
| 分離設計     | イベント種別ごとに関数を分けて登録・管理する設計方針 |

---

### 活用シーンと利点

| シーン         | 内容                            |
| ----------- | ----------------------------- |
| GUI操作       | ボタン・入力・ウィンドウ操作などのイベントに対処      |
| ゲームプログラミング  | プレイヤー操作やゲーム状態遷移の処理            |
| 通信プロトコル処理   | データ到着・接続断などの非同期イベントに応答        |
| Webアプリケーション | フロントエンドでのDOMイベントやAPIコールバックの処理 |

---
## 8章: 標準的なイベント登録構文

---

### 解説

Pythonの標準ライブラリには、イベント駆動的な設計をサポートするための「コールバック登録構文」がいくつか用意されている。代表的なものには `atexit.register()` や `signal.signal()` があり、それぞれ「プログラム終了時」や「特定のシグナル受信時」に実行される関数を登録できる。

これらは内部的に「コールバックを受け取って登録し、特定のタイミングで実行する」という構造を持っており、イベント駆動設計の本質を標準機能で体験できる例である。

---

### `atexit.register()` による終了時処理の登録

```python
import atexit

def on_exit():
    print("プログラム終了時に実行")

atexit.register(on_exit)

print("メイン処理実行中")
```

`atexit.register()` に関数を渡すことで、プログラムが正常終了する際にその関数が呼び出される。終了処理のカプセル化に有効。

---

### `signal.signal()` によるシグナルハンドラ登録

```python
import signal
import sys

def handle_sigint(signum, frame):
    print("SIGINTを受信しました")
    sys.exit(0)

signal.signal(signal.SIGINT, handle_sigint)

while True:
    pass  # Ctrl+C で終了
```

`signal.signal()` はUNIX系OSで有用なシグナル処理APIで、特定のシグナル（例：SIGINT）に対応する関数を登録することができる。

---

### 明示的な登録と解除の管理

`signal.signal()` や一部のイベント処理では、登録された関数をあとから変更・解除することができる。これにより、柔軟なライフサイクル管理が可能になる。

```python
import signal

def handler1(sig, frame): print("ハンドラ1")
def handler2(sig, frame): print("ハンドラ2")

signal.signal(signal.SIGUSR1, handler1)
signal.signal(signal.SIGUSR1, handler2)  # 上書きされる
```

この例では2つ目の登録によって、最初のハンドラが上書きされている。複数登録が可能なイベントもあれば、上書き形式のものもあるため注意が必要。

---

### 用語と構造の整理

| 構文・API名                 | 説明                              |
| ----------------------- | ------------------------------- |
| `atexit.register(func)` | プログラム正常終了時に実行される処理を登録           |
| `signal.signal(sig, h)` | OSシグナル（例: SIGINT）に対して処理関数を割り当てる |
| シグナルハンドラ                | 指定シグナル発生時に呼ばれる関数                |
| 登録解除                    | イベントに対するコールバックを再登録／上書きする操作      |

---

### 比較まとめ：登録型コールバックAPIの違い

| API名              | 登録先     | 発火条件            | 登録方式   |
| ----------------- | ------- | --------------- | ------ |
| `atexit.register` | プログラム終了 | 正常終了時           | 複数登録可  |
| `signal.signal`   | シグナル種別  | SIGINT/SIGTERM等 | 上書き式   |
| `threading.Timer` | 時間指定    | 指定秒数後に発火        | 単発・1関数 |

---

### 活用シーン

| シーン             | 内容                   |
| --------------- | -------------------- |
| プログラム終了時のリソース解放 | 一時ファイルやセッションの後処理     |
| Ctrl+C の安全な処理   | キーボード割り込みへの対応        |
| 外部シグナル処理        | サーバプロセスの終了通知、再起動指示など |

---
