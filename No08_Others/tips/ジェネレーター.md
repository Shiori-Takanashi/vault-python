> ## ジェネレーターの基本

---

> ### ジェネレーターとは

* **イテレーターの一種**
* `__iter__()` と `__next__()` を自動的に持つ
* `yield` を使って、値を**逐次的に返す関数**で作成
* 状態を保持したまま **中断 → 再開** が可能
* **メモリ効率が良く、リスト全体を保持しない**

---

> ### ジェネレーター ≠ イテラブル ≠ イテレーター

| 概念      | 説明                    | 実装要件                        |
| ------- | --------------------- | --------------------------- |
| イテラブル   | `for` で回せるもの          | `__iter__()` を持つ            |
| イテレーター  | `next()` で1つずつ取り出せるもの | `__iter__()` + `__next__()` |
| ジェネレーター | `yield` で値を返す特殊な関数    | 実行するとイテレーターを返す              |

```python
def g():
    yield 1
gen = g()

isinstance(gen, Iterator)  # True
isinstance(gen, Iterable)  # True
```

---

> ### 通常の関数との違い

| 比較対象    | 通常の関数    | ジェネレーター             |
| ------- | -------- | ------------------- |
| 使用キーワード | `return` | `yield`             |
| 戻り値     | 値        | ジェネレーター（イテレーター）     |
| 実行時の動作  | 全体を一度に実行 | `yield` で中断しながら逐次実行 |
| 状態の保持   | 毎回初期化される | 途中の状態を保持して再開可能      |

---

> ### 基本構文と動作

```python
def count_up_to(n):
    i = 1
    while i <= n:
        yield i
        i += 1

gen = count_up_to(3)
next(gen)  # 1
next(gen)  # 2
next(gen)  # 3
next(gen)  # StopIteration
```

---

> ### `for` 文との併用（推奨）

```python
for val in count_up_to(3):
    print(val)  # 1, 2, 3
```

✅ `for` 文は内部で `next()` を使い、`StopIteration` を自動処理するため安全。

---

> ### ジェネレーター式（generator expression）

```python
gen = (x * x for x in range(3))

next(gen)  # 0
next(gen)  # 1
next(gen)  # 4
```

* `()` で囲むとジェネレーター式
* `[]` のリスト内包表記と似ているが、**遅延評価されメモリを消費しない**

---

> ### メモリ効率と主な用途

* 要素数が多い場合でも **一度に全体を保持しない**
* ファイルの行処理・ストリーム処理・巨大データ処理に適する
* 複雑なループ状態の管理や、再開可能な処理にも向く

---

> ### `yield` と `return` の併用

```python
def example():
    yield 1
    return 99

gen = example()
next(gen)      # 1
next(gen)      # StopIteration(99)
```

* `return` で終了すると `StopIteration(value)` が発生し、`value` は `.args[0]` に格納される

---

> ### `yield from`：入れ子の展開

```python
def sub():
    yield 1
    yield 2

def main():
    yield from sub()
    yield 3

list(main())  # [1, 2, 3]
```

📌 `yield from` は「サブイテレーターの要素をすべて順にyieldする」構文糖衣

---

> ### 補足：ジェネレーターは一度きり

```python
gen = (x for x in range(3))
list(gen)  # [0, 1, 2]
list(gen)  # []（すでに消費されたため空）
```

✅ ジェネレーターは「消費型」。再利用はできない。

---

> ### ジェネレーターの検出

```python
from collections.abc import Iterator, Iterable
from types import GeneratorType

def gen(): yield 1

g = gen()

isinstance(g, GeneratorType)  # True
isinstance(g, Iterator)       # True
isinstance(g, Iterable)       # True
```

---
