---

title: python-class-lesson
type: content
order: 1

---

## 01章: クラスとインスタンス

---


## 概要
Pythonにおけるクラスは、オブジェクト指向の中核をなす構文要素であり、関連するデータ（属性）と処理（メソッド）を1つにまとめて扱えるようにするための仕組みである。この章では、`class` を使ったクラスの定義から、インスタンス生成、属性操作の基本までを体系的に解説する。



### クラス

Pythonでは `class` キーワードを用いてクラスを定義する。以下は最小限のクラス定義である。
この構文は「MyClass」という名前の空のクラスを定義している。

```python
class MyClass:
    pass
```


### インスタンス

定義したクラスは、関数のように `()` をつけて呼び出すことでインスタンス（＝クラスから生成される具体的なオブジェクト）を作る。
この `obj` は `MyClass` 型のインスタンスである。`()` の部分は `__init__()` メソッドの呼び出しに対応する（次章で詳述）。


```python
obj = MyClass()
```




### クラスとインスタンスの違い

| 比較対象    | クラス (`class`)  | インスタンス (`instance`) |
| - | -- | - |
| 定義タイミング | プログラム実行前に定義される | 実行時に生成される           |
| 役割      | 設計図            | 設計図から作られた実体         |
| 属性の共有   | クラス変数を通じて共有可   | インスタンス変数で個別に保持      |
| 振る舞い    | メソッドの定義側       | メソッドの呼び出し側          |



### 動的な属性

Pythonのインスタンスには、後から自由に属性を追加できる動的性がある。

```python
obj.name = "Tanaka"
print(obj.name)  # Tanaka
```

この動作は `__dict__` 属性に保存されており、実体は次のように確認できる。

```python
print(obj.__dict__)
# {'name': 'Tanaka'}
```



### インスタンス生成の挙動確認例

```python
class Empty:
    pass

a = Empty()
b = Empty()
a.val = 100

print(a.__dict__)  # {'val': 100}
print(b.__dict__)  # {}
```

このように、`a` と `b` は同じクラスから生成されていても、それぞれが独立した属性空間を持っている。



### 属性へのアクセスと存在確認

属性アクセスにはドット演算子を用いるが、存在しない属性にアクセスすると `AttributeError` となる。回避には `hasattr()` を使う。

```python
if hasattr(a, 'val'):
    print(a.val)
```



### 動的メソッド

このように、インスタンスレベルでも関数を動的にバインドできる。これは後の「関数オブジェクトとしてのメソッド」の理解に通じる。

```python
def greet(self):
    return f"Hello, {self.name}"

import types
a.greet = types.MethodType(greet, a)
print(a.greet())  # Hello, Tanaka
```

### 型の確認

#### `type(obj)`
インスタンスの型がどのクラスかを確認できる。

```python
print(type(a))  # <class '__main__.Empty'>
```

#### `isinstance(obj, ClassName)`
あるオブジェクトが特定のクラス由来かを調べることも可能である。

```python
class Animal:
    pass

class Dog(Animal):
    pass

d = Dog()

print(isinstance(d, Dog))      # True
print(isinstance(d, Animal))   # True
print(type(d) == Dog)          # True
print(type(d) == Animal)       # False
```

### 相違点

* `type()` は「厳密な型の一致」を調べる（継承関係を無視）
* `isinstance()` は「継承を含む型の所属」を調べる（柔軟な判定）

* 両者はオーバーライドの確認やポリモーフィズムの文脈でも重要になる。

### 用語整理

#### クラス（Class）

クラスとは、属性（データ）とメソッド（処理）の定義をまとめたテンプレート構造である。
設計図のような役割を持ち、実体は持たないが、そこから複数のインスタンスを生成することが可能である。
Pythonでは `class クラス名:` の構文で定義され、すべてのオブジェクトの基本型として機能する。

#### インスタンス（Instance）

インスタンスとは、クラスから生成された具体的なオブジェクトである。
各インスタンスは、独立した属性の状態を持ち、クラスに定義されたメソッドを通じて振る舞いを実行することができる。
同じクラスから複数のインスタンスを生成することで、それぞれ異なる状態を保持させることが可能である。

#### 属性（Attribute）

属性とは、インスタンスに紐づけられたデータであり、オブジェクトの状態を表現するために使用される。
クラス内で `self.属性名 = 値` の形式で定義され、インスタンスごとに異なる値を保持することができる。
属性には、外部から `obj.属性名` としてアクセスすることができる。

#### メソッド（Method）

メソッドとは、クラスに定義された関数であり、インスタンスのデータに対して処理を行う手段である。
通常は第一引数として `self` を取り、呼び出し元のインスタンス自身を参照できるようにする。
インスタンスメソッドを通じて、属性の変更や、特定の挙動の実装を行うことができる。

#### `__dict__`（Instance Namespace Dictionary）

`__dict__` とは、インスタンスが現在保持している属性名とその値を格納する辞書型の内部構造である。
インスタンスの状態を確認したり、動的に属性を追加・変更するために活用される。
クラス変数はこの辞書には含まれず、純粋にそのインスタンスに属する情報のみが格納される。

以下は、`type()` と `isinstance()` に関する解説を、他と統一した「〜である」調・英語名付き・h4形式でまとめたものである：

#### `type()`（Type Inspection Function）

`type()` とは、オブジェクトの厳密な型（クラス）を判定するための組み込み関数である。
この関数は、そのオブジェクトが**どのクラスによって生成されたか**を直接返す。
継承関係を考慮せず、インスタンスのクラスが**完全に一致しているか**を確認する際に用いられる。
例えば `type(obj) == SomeClass` のようにして、型の厳密性を比較する目的で使われる。

#### `isinstance()`（Instance Membership Check）

`isinstance()` とは、あるオブジェクトが特定のクラス、またはそのサブクラスのインスタンスであるかどうかを判定する関数である。
継承関係を考慮するため、ポリモーフィズムの文脈において柔軟な型判定が可能である。
複数クラスをタプルで指定することで、いずれかのクラス由来であれば `True` を返すようにも設計されている。
例えば `isinstance(obj, (int, float))` のような使用も可能である。



---

## 02章: コンストラクタ `__init__` の役割

Pythonにおけるクラスでは、インスタンス生成時に特定の初期処理を行いたい場面が多い。そのための仕組みがコンストラクタであり、Pythonでは `__init__` メソッドとして提供されている。本章では `__init__` の基本的な役割と、`self`・引数・デフォルト値などの関連要素について詳細に解説する。

---

### `__init__` の構文と自動呼び出し

```python
class User:
    def __init__(self):
        print("インスタンスが生成されました")
```

このように定義されたクラスにおいて、インスタンスを作ると自動的に `__init__` が呼び出される。

```python
u = User()  # => インスタンスが生成されました
```

`__init__` はあくまでインスタンスの初期化処理を担当する。戻り値は不要で、常に `None` を返す仕様である（`return` 文は不要）。

---

### `self` の意味と必須性

`__init__` の第一引数には必ず `self` を書く。これは「これから生成されるインスタンス自身」を指す参照であり、インスタンスに属性を追加したり状態を保持するために不可欠である。

```python
class User:
    def __init__(self):
        self.name = "Tanaka"
```

このとき `self.name` はインスタンスごとに異なる値を保持可能な属性となる。

---

### 引数付きの初期化

`__init__` は任意の引数を受け取ることができる。これにより、インスタンスごとに異なる初期状態を設定できる。

```python
class User:
    def __init__(self, name, age):
        self.name = name
        self.age = age
```

```python
u1 = User("Yamada", 20)
u2 = User("Suzuki", 35)

print(u1.name)  # Yamada
print(u2.age)   # 35
```

---

### デフォルト引数による柔軟な初期化

全ての引数を必須にすると使い勝手が悪くなるため、Pythonでは関数と同様に `__init__` でもデフォルト引数を設定できる。

```python
class User:
    def __init__(self, name="Unknown", age=0):
        self.name = name
        self.age = age
```

```python
u = User()
print(u.name)  # Unknown
```

---

### 属性の確認と辞書化

前章で説明した `__dict__` を使えば、`__init__` によってどのような属性が追加されたかを確認できる。

```python
print(u.__dict__)  # {'name': 'Unknown', 'age': 0}
```

---

### `__init__` を使わない場合との違い

```python
class Empty:
    pass

e = Empty()
e.name = "X"
```

これは動的に属性を追加した例である。対して、`__init__` を使うと明示的かつ構造化された初期化ができるというメリットがある。

---

### 補足: `__init__` の呼ばれ方とタイミング

`__init__` は以下のような順序で呼ばれる：

1. クラスの定義が評価される（クラスオブジェクトの生成）
2. `()` によりインスタンスが生成される
3. 自動的に `__init__` が呼び出される

---

### 用語整理

| 用語         | 説明                    |
| ---------- | --------------------- |
| `__init__` | インスタンス初期化のための特別メソッド   |
| `self`     | 自身のインスタンスへの参照         |
| 引数         | インスタンスごとに異なる初期状態を受け取る |
| デフォルト値     | 引数省略時の自動補完値           |

---


## 03章: インスタンス変数とクラス変数

Pythonのクラスでは、データの格納先として「インスタンス変数」と「クラス変数」という2種類の変数を扱う。両者は定義場所と共有の範囲が異なり、使い方を誤るとバグや予期しない副作用を生む。本章では、これらの違いと内部構造、確認方法について整理する。

---

### インスタンス変数の定義と挙動

インスタンス変数は、`self.` を使ってインスタンスごとに保持される。

```python
class User:
    def __init__(self, name):
        self.name = name
```

```python
a = User("Taro")
b = User("Jiro")

print(a.name)  # Taro
print(b.name)  # Jiro
```

このように、各インスタンスはそれぞれ独立した `name` を持っており、他のインスタンスとは無関係に保持される。

---

### クラス変数の定義と共有性

クラス変数は、クラス定義ブロック内に `self.` を使わず直接定義された変数である。全インスタンス間で共有される。

```python
class Counter:
    count = 0  # クラス変数

    def __init__(self):
        Counter.count += 1
```

```python
a = Counter()
b = Counter()
print(Counter.count)  # 2
```

クラス変数は全体で1つの実体を持ち、クラスオブジェクトに結びついている。

---

### 変更の影響範囲

クラス変数は共有されるため、変更が他のインスタンスにも影響する。

```python
class Sample:
    shared = []

a = Sample()
b = Sample()

a.shared.append(1)
print(b.shared)  # [1]
```

これは、`shared` がミュータブル（リスト）であり、1つのオブジェクトを共有しているためである。

---

### インスタンス変数の追加とクラス変数の遮蔽

インスタンス側で同名の変数を定義すると、クラス変数が「見えなくなる（遮蔽される）」。

```python
class Example:
    value = 10

e = Example()
e.value = 20  # インスタンス変数として新たに追加

print(e.value)         # 20（インスタンス変数）
print(Example.value)   # 10（クラス変数）
```

このとき `e.__dict__` には `value` が含まれ、`Example.__dict__` には別の `value` が存在する。

---

### `self.変数` と `クラス名.変数` の違い

| 記法                 | 解釈                | 使用対象       |
| ------------------ | ----------------- | ---------- |
| `self.name = ...`  | インスタンス変数の定義       | インスタンス単位   |
| `Class.name = ...` | クラス変数の定義・変更       | 全体で共有される状態 |
| `self.name` の読み取り  | インスタンス → クラスの順に探索 | 影響範囲の限定可   |

---

### `__dict__` による内部状態の確認

`__dict__` を使えば、インスタンス変数やクラス変数の格納場所を明確に確認できる。

```python
class Sample:
    x = 1

s = Sample()
s.y = 2

print(s.__dict__)        # {'y': 2}
print(Sample.__dict__)   # {'x': 1, ...}
```

`__dict__` は読み取り専用ではなく、属性の追加・変更にも利用できるが、通常はドット記法が望ましい。

---

### クラス変数の利用上の注意

* **ミュータブル型（リスト・辞書など）の共有は要注意**
* **定数用途（すべてのインスタンスで同じ値）には適している**
* **動的な状態管理にはインスタンス変数を使う**

---
## 04章: メソッド定義と `self` の意味

クラスにおけるメソッドは、インスタンスと結びついて動作する関数である。通常の関数とは異なり、呼び出し元となるオブジェクト（インスタンス）を参照できるように `self` 引数が必要となる。本章では、メソッドの定義・呼び出し方法・`self` の意味とその必要性について詳述する。

---

### メソッドの定義方法

Pythonではクラス内に `def` で関数を定義すると、それはメソッドとして扱われる。最初の引数に `self` を指定することで、呼び出し元インスタンスにアクセスできる。

```python
class Dog:
    def bark(self):
        print("ワン！")
```

```python
d = Dog()
d.bark()  # => ワン！
```

---

### `self` の役割

`self` は、そのメソッドがどのインスタンスから呼び出されたのかを示す参照である。Pythonでは明示的に書く必要があり、暗黙に補われることはない（JavaやC++とは異なる点）。

```python
class Cat:
    def say_name(self):
        print(f"My name is {self.name}")

c = Cat()
c.name = "Mii"
c.say_name()  # => My name is Mii
```

このように、`self` を通じてインスタンス変数にアクセスすることが可能になる。

---

### インスタンスからの呼び出しとバインディング

メソッドを `インスタンス.メソッド()` という形で呼び出すと、自動的に `self` にそのインスタンスが渡される。

```python
d = Dog()
Dog.bark(d)  # メソッド呼び出しと同等（内部的にはこうなる）
```

このように、`self` の渡し方は文法上は暗黙的だが、明示的に見ることも可能である。

---

### メソッド内での状態更新

メソッドは `self` を通じてインスタンスの状態（属性）を読み書きする。

```python
class Counter:
    def __init__(self):
        self.count = 0

    def increment(self):
        self.count += 1
```

```python
c = Counter()
c.increment()
print(c.count)  # 1
```

---

### 外部からの呼び出しと内部的な関数との違い

通常の関数は引数を明示的に渡す必要があるが、メソッドはインスタンスがそのまま渡される。

```python
def greet(user):
    print(f"Hello, {user.name}")

class User:
    def __init__(self, name):
        self.name = name

    def greet(self):
        print(f"Hello, {self.name}")
```

このように、関数ベースの構造とメソッドベースの構造は、処理の意味は似ていても記述と責務の持ち方が異なる。

---

### ドキュメントと関数オブジェクトとしての扱い

Pythonのメソッドは、関数オブジェクトとして属性としてもアクセスできる。

```python
print(Counter.increment.__name__)  # increment
print(Counter.increment.__doc__)   # None（未記述のため）
```

また、インスタンスからメソッドを取り出すと、`self` が束縛された「バウンドメソッド」となる。

```python
method = c.increment
method()  # 呼び出し可能、selfは自動で束縛済み
```

---

### 注意点と補足

* `self` は予約語ではなく慣例。任意の名前にできるが、変更しないこと。
* `@staticmethod` や `@classmethod` では `self` を使わない。これらは次章以降で扱う。
* メソッドと関数の明確な違いは「束縛されたインスタンスを持つかどうか」にある。

---
## 05章: `__str__`・`__repr__` の使い分け

Pythonでは、オブジェクトを文字列として表示する際に使われる特別なメソッドとして `__str__` と `__repr__` が用意されている。この2つは似ているようで用途が異なり、適切に実装し使い分けることで、ユーザビリティとデバッグ性を高められる。本章では両者の違いと使いどころを整理する。

---

### `__str__`: 人間向けの出力

`__str__` は `print()` や `str()` を通じて呼び出される。人間にとって読みやすい、簡潔な出力が求められる。

```python
class User:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return f"User: {self.name}"
```

```python
u = User("Tanaka")
print(u)  # => User: Tanaka
```

これは、ユーザーが画面で確認する用途に適している。

---

### `__repr__`: 開発者向け・再現可能な出力

`__repr__` は `repr()` や、インタラクティブシェル上での出力、ログなどで使われる。デバッグやトレーシングのために、できるだけ「再現性のある」表現にすることが望ましい。

```python
class User:
    def __repr__(self):
        return f"User(name={self.name!r})"
```

```python
repr(u)  # => User(name='Tanaka')
```

このように、評価可能な文字列（`eval()` で再生成可能な形式）を目指すのが一般的である。

---

### 両方を同時に定義する例

```python
class User:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return f"{self.name}"

    def __repr__(self):
        return f"User(name={self.name!r})"
```

```python
u = User("Miki")
print(str(u))   # Miki
print(repr(u))  # User(name='Miki')
```

---

### `print()` と `repr()` の違い

| 操作           | 呼び出されるメソッド   |
| ------------ | ------------ |
| `print(obj)` | `__str__()`  |
| `str(obj)`   | `__str__()`  |
| `repr(obj)`  | `__repr__()` |
| シェルで `obj`   | `__repr__()` |

Pythonシェル上での表示では、`__repr__` が優先される。

---

### `__str__` が未定義の場合の挙動

`__str__` が未定義の場合、`print()` などでは自動的に `__repr__` が代用される。

```python
class A:
    pass

a = A()
print(a)       # <__main__.A object at 0x...>（repr出力）
```

---

### データクラスでのデフォルト挙動

Pythonの `@dataclass` を使うと、`__repr__` は自動で定義される。`__str__` は定義されないため、必要に応じて手動で上書きする。

```python
from dataclasses import dataclass

@dataclass
class Item:
    name: str
    price: int
```

```python
i = Item("apple", 100)
print(i)       # Item(name='apple', price=100)
```

---

### 設計上の指針

| 観点    | `__str__`        | `__repr__`                        |
| ----- | ---------------- | --------------------------------- |
| 対象    | ユーザー、エンドユーザー     | 開発者、デバッグ、ログ                       |
| 内容    | 簡潔で読みやすい         | 詳細で再現性のある                         |
| 使用場面  | `print()` などでの出力 | シェル表示、ログ、例外メッセージ                  |
| 実装の目安 | 人が読んで理解できれば十分    | `eval(repr(obj)) == obj` を目指す場合あり |

---
## 06章: `@property`の導入

Pythonでは、メソッドをあたかも属性のように扱うための仕組みとして `@property` デコレータが用意されている。これにより、外部からのアクセスは通常の属性と同じ書き方を維持しつつ、内部的には関数を通して制御された処理を行うことが可能になる。本章では `@property` の基本的な使い方と、setterによる書き込み対応、注意点などを扱う。

---

### メソッドを属性のように読み取る

通常、クラスに定義したメソッドは `()` をつけて呼び出す必要がある。しかし `@property` を使えば、関数でありながら属性アクセスのような記法に変換できる。

```python
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def diameter(self):
        return self._radius * 2
```

```python
c = Circle(10)
print(c.diameter)  # => 20（メソッドだが () 不要）
```

このとき、`diameter` は外から見ると「読み取り専用の属性」に見える。

---

### setter による書き込み対応

`@property` は読み取り専用だが、対応する `@プロパティ名.setter` を定義すれば書き込み可能な属性として扱える。

```python
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):
        return self._radius

    @radius.setter
    def radius(self, value):
        if value < 0:
            raise ValueError("負の半径は許されません")
        self._radius = value
```

```python
c = Circle(5)
c.radius = 10
print(c.radius)  # => 10
```

このように、代入操作の裏でバリデーションや副作用を含めることができる。

---

### deleter も定義可能

`@プロパティ名.deleter` を使うことで、`del` による削除にもフックをかけられる。

```python
class Sample:
    @property
    def value(self):
        return self._val

    @value.deleter
    def value(self):
        print("値を削除しました")
        del self._val
```

---

### 属性アクセスと関数呼び出しの違いを曖昧化

`@property` を使うことで、「見た目は属性、実体は関数」という構成が可能になる。

```python
print(c.diameter)      # 属性アクセスのように見える
print(c.diameter())    # ← エラー（関数ではない）
```

この曖昧性は意図的な設計によるものであり、ユーザーの視点から見たインターフェースをシンプルに保つ効果がある。

---

### 命名規約と実装パターン

慣例的に、外部に公開するプロパティは `radius`、内部実体は `_radius` のようにアンダースコア付きで管理する。

```python
self._x  # 内部変数
@property
def x(self): return self._x
```

---

### 用途の具体例

* **読み取り専用属性の定義**：例）計算で得られる面積など
* **入力値のバリデーション**：setter に制約ロジックを実装
* **内部状態の隠蔽と管理**：外部に対して安定したインターフェースを提供

---

### 注意点

* パフォーマンスの高い呼び出しを前提としない（プロパティは毎回関数を通る）
* 複雑な処理を隠蔽しすぎると、意図しない副作用を見落としやすくなる
* 書き込み禁止を明示したい場合、setter を定義しない（読み取り専用にする）

---
## 07章: クラスメソッドとスタティックメソッド

Pythonのクラスには、インスタンスから呼び出す通常のメソッド以外に、**クラスメソッド**（`@classmethod`）と**スタティックメソッド**（`@staticmethod`）という2つの特別なメソッド形態が存在する。それぞれ `self` とは異なる目的で使用され、設計上の意図を明確に表現するのに役立つ。本章ではこの2つの違いと使い分けについて詳しく解説する。

---

### クラスメソッドとは

クラスメソッドは、**クラスオブジェクト自身（`cls`）を第一引数として受け取る**メソッドであり、`@classmethod` デコレータで定義する。

```python
class User:
    user_count = 0

    def __init__(self, name):
        self.name = name
        User.user_count += 1

    @classmethod
    def get_user_count(cls):
        return cls.user_count
```

```python
print(User.get_user_count())  # => 0 → 1 → ...
```

このように、クラスメソッドは**インスタンス化せずに**呼び出すことができ、**クラス変数へのアクセス**や**代替コンストラクタ**としての利用に適している。

---

### スタティックメソッドとは

スタティックメソッドは、**インスタンスやクラスと無関係な汎用処理**をクラスの内部に整理して記述するための手段であり、`@staticmethod` デコレータで定義する。

```python
class Math:
    @staticmethod
    def add(x, y):
        return x + y
```

```python
print(Math.add(3, 5))  # => 8
```

このように、引数に `self` や `cls` を取らず、**関数的な処理をクラス内に整理する目的**で使用する。

---

### 3種のメソッドの比較

| 特徴     | 通常のメソッド        | クラスメソッド      | スタティックメソッド   |
| ------ | -------------- | ------------ | ------------ |
| 第一引数   | `self`（インスタンス） | `cls`（クラス）   | なし           |
| 呼び出し主体 | インスタンス         | クラスまたはインスタンス | クラスまたはインスタンス |
| 用途     | 状態操作           | クラス状態の取得・生成  | 補助的な処理       |
| 代表用途   | 属性の読み書き        | 工場メソッドなど     | 汎用ユーティリティ    |

---

### Factory Methodとしての活用

クラスメソッドは、**複数の生成パターンを提供する目的**で用いられることが多い。

```python
class User:
    def __init__(self, name):
        self.name = name

    @classmethod
    def from_dict(cls, d):
        return cls(d["name"])
```

```python
u = User.from_dict({"name": "Tanaka"})
```

これは、`__init__` の直接呼び出しよりも**柔軟で表現力のある構築方法**を提供できる。

---

### スタティックメソッドでのユーティリティ関数

スタティックメソッドは、**クラスに論理的に属するが状態に依存しない処理**に適している。

```python
class TextUtils:
    @staticmethod
    def is_ascii(s):
        return all(ord(c) < 128 for c in s)
```

```python
print(TextUtils.is_ascii("hello"))     # True
print(TextUtils.is_ascii("こんにちは"))  # False
```

このように、**グローバル関数として切り出すよりも構造化され、名前空間の整理にもつながる**。

---

### 注意事項

* `@classmethod` は継承時に `cls` が子クラスを指すため、再利用性が高い
* `@staticmethod` は他言語の静的関数と近く、特にPythonでは設計意図の明示に有効
* どちらも**インスタンス状態（`self`）が不要な場合の設計上の選択肢**となる

---

