# 📢Python-Class-Lesson-Index


---

## 📍第01部：クラスの基礎

---


### 📝第01章_クラス定義とインスタンス化の基本

* `class` によるクラス定義構文
* インスタンスの生成と `()` の意味
* クラスとインスタンスの違い
* 動的な属性追加と基本的な操作



### 📝第02章_コンストラクタ `__init__` の役割

* `__init__` の自動呼び出しの仕組み
* `self` によるインスタンス自身の参照
* 引数の受け取りと内部状態の初期化
* デフォルト引数による柔軟な初期化



### 📝第03章_インスタンス変数とクラス変数

* インスタンス変数とクラス変数の違い
* クラス変数の共有性と副作用のリスク
* `self.変数` と `クラス名.変数` の違い
* `__dict__` による実体の確認



### 📝第04章_メソッド定義と `self` の意味

* クラス内の関数をメソッドと呼ぶ
* `self` はインスタンスを表す第一引数
* メソッド内から状態へアクセス・更新
* 外部からのメソッド呼び出し方法



### 📝第05章_`__str__`・`__repr__` の使い分け

* `__str__` は人間向けの表示用
* `__repr__` は開発者・デバッグ向け
* `print()` と `repr()` での挙動の違い
* 再現可能性と可読性の両立



### 📝第06章_`@property`の導入

* メソッドを属性として扱うための仕組み
* `@property` による読み取り専用の設計
* `@プロパティ名.setter` による書き込み対応
* 属性アクセスと関数呼び出しの境界の曖昧化



### 📝第07章_クラスメソッドとスタティックメソッド

* `@classmethod` はクラス自身（`cls`）を扱う
* `@staticmethod` は `self`・`cls` を受け取らない
* 工場メソッドとしての `from_xxx()` 構文
* ユーティリティ関数としての利用設計

---

## 📍第02部：オブジェクト指向

---

### 📝第08章_継承と拡張

* `class 子クラス(親クラス):` による定義
* 継承によるメソッド・属性の再利用
* 子クラスによる機能の追加・変更
* 継承階層におけるコード設計上の注意



### 📝第09章_`super()` について

* `super()` の基本構文と意味
* `__init__()` の継承時の書き方
* 多重継承における `super()` の動作
* MRO（Method Resolution Order）との関係



### 📝第10章_メソッドのオーバーライド

* 同名メソッドの再定義（オーバーライド）
* `isinstance()` と `type()` の違い
* オーバーライド時の親メソッド呼び出し
* ポリモーフィズムの基礎



### 📝第11章_多重継承とメソッド解決順序

* 複数の親クラスを持つ構文
* `super()` の呼び出し順と MRO
* C3リニアリゼーションの概念
* 多重継承時の衝突と設計の難しさ



### 📝第12章_抽象クラスとインタフェース

* `abc.ABC` による抽象クラス定義
* `@abstractmethod` の使い方
* 抽象メソッドを持つクラスのインスタンス化制限
* 抽象クラスによる設計上の制約の明示



### 📝第13章_ダックタイピング

* ダックタイピングの考え方
* 明示的な継承を使わない柔軟な設計
* `hasattr()` による動的インタフェース判定
* Pythonにおける静的型との設計方針の違い

---

## 📍第03部：特殊メソッドとデータモデル

---

### 📝第14章_比較演算子のオーバーロード

* 比較演算子をカスタマイズ可能
* `__eq__`, `__ne__`, `__lt__`, `__le__`, `__gt__`, `__ge__` の実装
* デフォルトではインスタンスのアドレス比較になる
* 値オブジェクト（等価性重視）の定義に有効



### 📝第15章_算術演算子のオーバーロード

* `+`, `-`, `*`, `/`, `%` などを独自定義できる
* `__add__`, `__sub__`, `__mul__`, `__truediv__`, `__mod__` などの導入
* 不変性（immutable）を保つために新しいオブジェクトを返す設計が推奨
* 異なる型との演算時の対処も考慮すべき



### 📝第16章_コンテキストマネージャ

* `with` 文に対応するクラス設計
* リソースの確保・解放の自動化
* `__enter__` で処理開始前のセットアップ
* `__exit__` で例外処理と終了処理を統一管理



### 📝第17章_イテレータ・イテラブル

* for文に対応するカスタムイテレータの定義
* `__iter__` はイテレータを返す
* `__next__` は次の要素を返すか `StopIteration` を送出
* ジェネレータとの使い分けを意識



### 📝第18章_コレクション的インタフェース

* インデックスアクセス・スライス・長さ取得などの実装
* `__getitem__` による `obj[i]` 対応
* `__setitem__`, `__delitem__` によるミュータブル操作対応
* `__len__` による `len(obj)` への対応

---

## 📍第04部：設計と実践

---

### 📝第19章_責任と分割

* 単一責任の原則（SRP）に基づく設計
* 一クラス一責務の原則とその意義
* 属性やメソッドの肥大化を避ける設計視点
* 分割による保守性・テスト容易性の向上



### 📝第20章_依存と合成

* 継承ではなく合成（委譲）を選ぶ判断基準
* クラス内で別クラスを持つ「has-a」関係の設計
* 継承による強結合のリスクと柔軟性の欠如
* 「委譲」による責務の明確化と再利用性



### 📝第21章_再利用性と拡張性

* 再利用可能な汎用クラスの特徴
* 拡張時に変更不要な設計（オープン/クローズド原則）
* 属性や引数の一般化と依存性注入（DI）への考慮
* 変更に強いAPI設計のための前提設計



### 📝第22章_`@dataclass` の導入

* `__init__`, `__repr__`, `__eq__` などの自動生成
* フィールドの型アノテーション必須
* 不変クラス（`frozen=True`）による安全性向上
* デフォルト値、デフォルトファクトリの使い分け
* `__post_init__()` による後処理の仕込み方



### 📝第23章_`@dataclass`との比較

* `NamedTuple`: イミュータブルなタプルベースの構造体
* `TypedDict`: 動的ディクショナリと型注釈の橋渡し
* `dataclass` との相違：継承・可変性・初期化処理の有無
* 用途ごとの選択基準と使い分けの明確化



### 📝第24章_設計について

* クラス単位でのモジュール分割（1ファイル1責務）
* 循環importの回避と設計的解消
* `__all__` による明示的な公開制御
* import構文とパス解決の整合性設計


---