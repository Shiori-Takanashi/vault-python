## コード例01

以下はこれまで学習したクラスの構文・機能をすべて含んだ実践例である。インスタンス変数・クラス変数・メソッド・__str__・__repr__・@property・@classmethod・@staticmethod などを活用して、ユーザー情報を管理・生成・加工する小さなユーティリティクラスを構築している。


```python
class User:
    # クラス変数：全体のユーザー数をカウント
    user_count = 0

    def __init__(self, name, age):
        # インスタンス変数：各ユーザー固有の属性
        self.name = name
        self._age = age
        User.user_count += 1

    # プロパティ：年齢を読み取り専用で提供
    @property
    def age(self):
        return self._age

    # プロパティsetter：年齢を安全に更新
    @age.setter
    def age(self, value):
        if value < 0:
            raise ValueError("年齢は0以上でなければなりません")
        self._age = value

    # 通常のメソッド：自己紹介を出力
    def introduce(self):
        return f"こんにちは、{self.name}です。{self.age}歳です。"

    # __str__：ユーザー表示用
    def __str__(self):
        return f"{self.name}（{self.age}歳）"

    # __repr__：開発者向け表現
    def __repr__(self):
        return f"User(name={self.name!r}, age={self.age!r})"

    # クラスメソッド：ユーザー数を取得
    @classmethod
    def get_user_count(cls):
        return cls.user_count

    # クラスメソッド：辞書から生成
    @classmethod
    def from_dict(cls, d):
        return cls(name=d["name"], age=d["age"])

    # スタティックメソッド：年齢が成人か判定
    @staticmethod
    def is_adult(age):
        return age >= 18
```

```python
# インスタンスの生成
u1 = User("Taro", 20)
u2 = User.from_dict({"name": "Jiro", "age": 15})

# メソッドとプロパティの使用
print(u1.introduce())        # => こんにちは、Taroです。20歳です。
print(u2.age)                # => 15
u2.age = 16
print(str(u2))               # => Jiro（16歳）
print(repr(u1))              # => User(name='Taro', age=20)

# クラスメソッドとスタティックメソッドの使用
print(User.get_user_count()) # => 2
print(User.is_adult(16))     # => False
print(User.is_adult(25))     # => True
```


---

## コード例02

以下は、2つのクラス `User` と `Group` を定義し、それらが連携して**対話的な使い方**ができるように構成した実践的なコード例である。ユーザーを複数登録し、グループ単位で管理・照会・追加・検査などが行える構成になっている。



```python
class User:
    user_count = 0  # クラス変数：総ユーザー数

    def __init__(self, name, age):
        self.name = name
        self._age = age
        User.user_count += 1

    @property
    def age(self):
        return self._age

    @age.setter
    def age(self, value):
        if value < 0:
            raise ValueError("年齢は0以上でなければなりません")
        self._age = value

    def introduce(self):
        return f"{self.name}です。年齢は{self.age}歳です。"

    def __str__(self):
        return f"{self.name}（{self.age}歳）"

    def __repr__(self):
        return f"User(name={self.name!r}, age={self.age!r})"

    @classmethod
    def from_dict(cls, d):
        return cls(name=d["name"], age=d["age"])

    @staticmethod
    def is_adult(age):
        return age >= 18
```



```python
class Group:
    def __init__(self, group_name):
        self.group_name = group_name
        self._members = []

    @property
    def members(self):
        return self._members.copy()

    def add_user(self, user):
        if not isinstance(user, User):
            raise TypeError("Userインスタンスのみ追加可能です")
        self._members.append(user)

    def list_adults(self):
        return [u for u in self._members if User.is_adult(u.age)]

    def __str__(self):
        names = ", ".join(u.name for u in self._members)
        return f"{self.group_name}メンバー: {names}"

    def __repr__(self):
        return f"Group({self.group_name!r}, members={self._members!r})"
```



```python
# ユーザーを作成
u1 = User("Taro", 22)
u2 = User("Jiro", 16)
u3 = User.from_dict({"name": "Hanako", "age": 30})

# グループを作成
g = Group("Team A")
g.add_user(u1)
g.add_user(u2)
g.add_user(u3)

# 対話的な利用
print(str(g))  # => Team Aメンバー: Taro, Jiro, Hanako

for member in g.members:
    print(member.introduce())
# => Taroです。年齢は22歳です。
# => Jiroです。年齢は16歳です。
# => Hanakoです。年齢は30歳です。

print("成人メンバー:")
for adult in g.list_adults():
    print(f"- {adult}")
# => - Taro（22歳）
# => - Hanako（30歳）

print(f"登録されたユーザー数: {User.get_user_count()}")  # => 3
```


---

## コード例03


以下は、**ユーザーとそのサブスクリプションを管理する対話的なクラス構成**のコード例である。`User` クラスが個人情報を持ち、`Subscription` クラスが契約内容・プラン・状態などを管理し、相互に連携する構成になっている。クラスメソッド・プロパティ・検証・文字列表現・検索機能など、実用に即した要素を盛り込んでいる。



```python
class Subscription:
    def __init__(self, plan, active=True):
        self.plan = plan
        self.active = active

    def cancel(self):
        self.active = False

    def activate(self):
        self.active = True

    @property
    def status(self):
        return "有効" if self.active else "無効"

    def __str__(self):
        return f"[{self.plan} プラン / {self.status}]"

    def __repr__(self):
        return f"Subscription(plan={self.plan!r}, active={self.active!r})"
```



```python
class User:
    user_count = 0

    def __init__(self, name, email, age):
        self.name = name
        self.email = email
        self._age = age
        self.subscription = None
        User.user_count += 1

    @property
    def age(self):
        return self._age

    @age.setter
    def age(self, value):
        if value < 0:
            raise ValueError("年齢は0以上でなければなりません")
        self._age = value

    def subscribe(self, plan):
        self.subscription = Subscription(plan)

    def cancel_subscription(self):
        if self.subscription:
            self.subscription.cancel()

    def has_active_subscription(self):
        return self.subscription is not None and self.subscription.active

    def __str__(self):
        sub = str(self.subscription) if self.subscription else "未契約"
        return f"{self.name}（{self.age}歳）: {sub}"

    def __repr__(self):
        return f"User(name={self.name!r}, email={self.email!r}, age={self.age!r})"

    @classmethod
    def from_dict(cls, d):
        return cls(d["name"], d["email"], d["age"])
```



```python
# ユーザー登録
alice = User("Alice", "alice@example.com", 28)
bob = User("Bob", "bob@example.com", 17)
carol = User.from_dict({"name": "Carol", "email": "carol@example.com", "age": 45})

# サブスクリプション契約
alice.subscribe("Premium")
bob.subscribe("Basic")
carol.subscribe("Basic")

# 対話的な情報確認
print(alice)  # => Alice（28歳）: [Premium プラン / 有効]
print(bob)    # => Bob（17歳）: [Basic プラン / 有効]

# サブスクリプションのキャンセル
bob.cancel_subscription()
print(bob)    # => Bob（17歳）: [Basic プラン / 無効]

# 有効契約者一覧
users = [alice, bob, carol]
print("有効なサブスクリプション契約者:")
for user in users:
    if user.has_active_subscription():
        print(f"- {user.name}: {user.subscription.plan}")
# => - Alice: Premium
# => - Carol: Basic

# 登録者総数
print(f"ユーザー数: {User.user_count}")  # => 3
```

---

## コード例04

```python
# user.py
from dataclasses import dataclass, field, asdict
from datetime import datetime
from typing import List, Optional


@dataclass
class SubscriptionEvent:
    event: str
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())


@dataclass
class Subscription:
    plan: str
    active: bool = True
    start_date: str = field(default_factory=lambda: datetime.now().date().isoformat())
    history: List[SubscriptionEvent] = field(default_factory=list)

    # ── 振る舞い ────────────────────────────────
    def cancel(self) -> None:
        if self.active:
            self.active = False
            self.history.append(SubscriptionEvent(event="cancel"))

    def activate(self) -> None:
        if not self.active:
            self.active = True
            self.history.append(SubscriptionEvent(event="activate"))

    def change_plan(self, new_plan: str) -> None:
        if new_plan != self.plan:
            self.plan = new_plan
            self.history.append(SubscriptionEvent(event=f"change_plan:{new_plan}"))

    # ── シリアライズ ────────────────────────────
    def to_dict(self) -> dict:
        d = asdict(self)
        # dataclass のネストをそのまま JSON 化
        d["history"] = [asdict(ev) for ev in self.history]
        return d

    @classmethod
    def from_dict(cls, d: dict) -> "Subscription":
        hist = [SubscriptionEvent(**ev) for ev in d.get("history", [])]
        return cls(
            plan=d["plan"],
            active=d["active"],
            start_date=d.get("start_date", datetime.now().date().isoformat()),
            history=hist,
        )

    # ── 表示 ────────────────────────────────────
    def __str__(self) -> str:
        status = "有効" if self.active else "無効"
        return f"[{self.plan} / {status}]"


@dataclass
class User:
    name: str
    email: str
    age: int
    subscription: Optional[Subscription] = None

    # ── ビジネスロジック ──────────────────────
    def subscribe(self, plan: str) -> None:
        self.subscription = Subscription(plan=plan)

    def cancel_subscription(self) -> None:
        if self.subscription:
            self.subscription.cancel()

    def has_active_subscription(self) -> bool:
        return bool(self.subscription and self.subscription.active)

    # ── シリアライズ ────────────────────────────
    def to_dict(self) -> dict:
        return {
            "name": self.name,
            "email": self.email,
            "age": self.age,
            "subscription": self.subscription.to_dict() if self.subscription else None,
        }

    @classmethod
    def from_dict(cls, d: dict) -> "User":
        sub = (
            Subscription.from_dict(d["subscription"])
            if d.get("subscription")
            else None
        )
        return cls(name=d["name"], email=d["email"], age=d["age"], subscription=sub)

    # ── 表示 ────────────────────────────────────
    def __str__(self) -> str:
        sub_str = str(self.subscription) if self.subscription else "未契約"
        return f"{self.name}（{self.age}歳）: {sub_str}"
```

```python
# user_storage.py
import json
from datetime import datetime
from pathlib import Path
from typing import List

from user import User


class UserStorage:
    def __init__(self, data_dir: str = "data") -> None:
        self.dir = Path(data_dir)
        self.dir.mkdir(parents=True, exist_ok=True)
        self.last_file = self.dir / "last_saved.json"

    # ── 永続化 ──────────────────────────────────
    def save_if_changed(self, users: List[User]) -> Path | None:
        current_data = [u.to_dict() for u in users]

        if self._is_same_as_last(current_data):
            print("変更なし：保存をスキップしました。")
            return None

        ts = datetime.now().strftime("%Y%m%d_%H%M%S")
        out_file = self.dir / f"user_data_{ts}.json"

        with out_file.open("w", encoding="utf-8") as f:
            json.dump(current_data, f, indent=2, ensure_ascii=False)

        with self.last_file.open("w", encoding="utf-8") as f:
            json.dump(current_data, f, indent=2, ensure_ascii=False)

        print(f"変更を検出: {out_file.name} に保存しました。")
        return out_file

    def _is_same_as_last(self, current: list) -> bool:
        if not self.last_file.exists():
            return False
        try:
            with self.last_file.open("r", encoding="utf-8") as f:
                prev = json.load(f)
            return current == prev
        except Exception:
            return False

    # ── 復元 ────────────────────────────────────
    def load_last(self) -> List[User]:
        if not self.last_file.exists():
            return []
        with self.last_file.open("r", encoding="utf-8") as f:
            raw = json.load(f)
        return [User.from_dict(d) for d in raw]
```

```python
# main.py
from user import User
from user_storage import UserStorage

store = UserStorage()

# ── ユーザー作成 ───────────────────────────────
alice = User("Alice", "alice@example.com", 28)
bob = User("Bob", "bob@example.com", 17)
carol = User("Carol", "carol@example.com", 45)

alice.subscribe("Premium")
bob.subscribe("Basic")
carol.subscribe("Basic")
bob.cancel_subscription()

users = [alice, bob, carol]

# ── 保存 ─────────────────────────────────────
store.save_if_changed(users)

# ── 何も変えずに再保存 → スキップされる ───────
store.save_if_changed(users)

# ── プラン変更して保存 ───────────────────────
alice.subscription.change_plan("Pro")
store.save_if_changed(users)

# ── 復元確認 ─────────────────────────────────
loaded = store.load_last()
print("\n復元結果:")
for u in loaded:
    print(u)
```

---


---

title: python-class-lesson
type: code
order: 3

---