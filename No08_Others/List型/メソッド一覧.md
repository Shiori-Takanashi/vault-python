
#  📢第1章：追加・拡張系メソッド

---

## 📍`append(x)`

### 概要

要素 `x` をリストの末尾に**そのまま追加**する。

###  使用例

```python
lst = [1, 2]
lst.append(3)
# 結果: [1, 2, 3]
```

### 想定用途

* データの蓄積
* ループや条件処理による動的リスト構築
* スタック構造の push 操作

###  注意点

* **ネストされる**：`append([4, 5])` の結果は `[1, 2, 3, [4, 5]]`
* 文字列に対して `append("abc")` すると1文字ずつではなく `"abc"` がそのまま要素になる

### 💡 パフォーマンス

* 計算量：**O(1)**（平均定数時間）
  リストの末尾に追加するため非常に高速

---

## 📍 `extend(iterable)`

### 概要

与えられたイテラブル（リスト・タプル・文字列など）の**全要素を展開して**末尾に追加する。

###  使用例

```python
lst = [1, 2]
lst.extend([3, 4])
# 結果: [1, 2, 3, 4]
```

###  想定用途

* 複数要素のまとめて追加
* 他のリスト・生成器との合成処理
* リスト同士の結合（破壊的）

### 注意点

* `lst.extend("abc")` の結果 → `['a', 'b', 'c']`
* `append()` と違い、要素は1つ1つ展開されて追加される
* **イテラブルでなければ TypeError**

### パフォーマンス

* 計算量：**O(k)**（kは追加される要素数）

---

## 📍  `insert(i, x)`

### 概要

インデックス `i` の位置に、要素 `x` を**挿入**する（既存要素は後ろにずれる）。

###  使用例

```python
lst = [1, 2, 4]
lst.insert(2, 3)
# 結果: [1, 2, 3, 4]
```

### 想定用途

* 任意位置への挿入（先頭・中央・末尾付近）
* 優先順位付きリストや並び順制御
* UI・CSV処理等での列挿入など

### 注意点

* `i` が負なら後ろから数える（例：`-1` は末尾手前）
* `i` が範囲外でもエラーにはならず、自動的に先頭または末尾に挿入される

### パフォーマンス

* 計算量：**O(n)**（nはリスト長）
  要素の移動が必要なため大きなリストでは遅くなる

---

# 📢第2章：削除系メソッド

---

## 📍 `pop([i])`

### 概要

指定インデックス `i` の要素を**取り出して削除**し、その値を返す。
引数を省略すると、**末尾の要素を削除して返す**。

### 使用例

```python
lst = [1, 2, 3]
x = lst.pop()      # x = 3, lst = [1, 2]
y = lst.pop(0)     # y = 1, lst = [2]
```

### 想定用途

* スタック（LIFO）操作
* リスト末尾からの逐次処理
* 一部要素の抽出と削除を同時に行う

### 注意点

* 空リストや不正インデックスで `IndexError`
* 戻り値を利用しない場合は `del` のほうが明示的

### パフォーマンス

* **O(1)**（末尾）
* **O(n)**（先頭） – 要素のシフトが必要なため

---

## 📍 `remove(x)`

### 概要

最初に出現する要素 `x` を検索して**削除**する。戻り値は無い。

### 使用例

```python
lst = [1, 2, 3, 2]
lst.remove(2)
# 結果: [1, 3, 2]
```

### 想定用途

* 値を指定した削除（インデックスが不要な場合）
* ユーザー入力などで選ばれた項目の除去
* 重複データの整理（先頭の1件だけ削除）

### 注意点

* 該当値が存在しないと `ValueError`
* 同じ値が複数ある場合は**最初の1つだけ削除**

### パフォーマンス

* 計算量：**O(n)**（検索＋削除）

---

## 📍 `clear()`

### 概要

リスト内の**すべての要素を削除**して空リストにする。

### 使用例

```python
lst = [1, 2, 3]
lst.clear()
# 結果: []
```

### 想定用途

* リストの初期化（再利用を前提）
* キャッシュ・バッファのリセット処理
* テストや一時処理の終了処理

### 注意点

* `lst.clear()` は**参照先も影響を受ける**
  （他の変数が同じリストを参照している場合）
* `lst = []` による代替とは意味が異なる（参照の切替）

### パフォーマンス

* 計算量：**O(n)**（内部処理は最適化されており高速）

---

# 📢第3章：検索・情報取得系メソッド

---

## 📍 `index(x[, start[, end]])`

### 概要

リスト内で**最初に `x` が現れるインデックスを返す**。見つからなければ `ValueError`。

### 使用例

```python
lst = ["a", "b", "c", "b"]
i = lst.index("b")        # 結果: 1
j = lst.index("b", 2)     # 結果: 3
```

### 想定用途

* 要素の位置を調べて操作対象を特定
* `remove()` などの前処理として位置取得
* サブリスト内の検索（`start`, `end` 範囲指定）

### 注意点

* 対象が存在しないと `ValueError`
* 複数該当しても**先頭の一致**のみ返す
* `start`, `end` はスライス同様（`end` は含まない）

### パフォーマンス

* 計算量：**O(n)**（最悪で全探索）


## 📍 `count(x)`

### 概要

リスト内における `x` の**出現回数を整数で返す**。

### 使用例

```python
lst = [1, 2, 2, 3, 2]
lst.count(2)  # 結果: 3
```

### 想定用途

* 重複確認（複数回あるか）
* 頻度の事前チェック（フィルタ分岐など）
* 統計的処理やフィルタリングの前処理

### 注意点

* 見つからない場合は `0`
* 要素数が多いとパフォーマンス劣化あり

### パフォーマンス

* 計算量：**O(n)**（全走査＋比較）

---

# 📢第4章：並び替え系メソッド

---

## 📍 `sort(*, key=None, reverse=False)`

### 概要

**リスト自身を並び替える**破壊的操作。戻り値は `None`。

### 使用例

```python
lst = [3, 1, 4]
lst.sort()
# 結果: [1, 3, 4]
```

### 想定用途

* データ整形（表示順や大小順の並び替え）
* アルゴリズムの前処理（整列済み前提）
* 集計やランキング処理前の準備

### 注意点

* 戻り値は `None`（代入すると `None` になる）
* 元リストが変更される（非可逆）
* 混在型（数値と文字列等）は `TypeError`
* `key` に関数を渡すと独自ソートが可能
* `reverse=True` で降順に並び替え

### パフォーマンス

* 計算量：**O(n log n)**（Timsortアルゴリズム使用）

---

## 📍 `reverse()`

### 概要

**リストの順序をその場で逆転**させる。並び替えではなく単純な反転。

### 使用例

```python
lst = [1, 2, 3]
lst.reverse()
# 結果: [3, 2, 1]
```

### 想定用途

* 降順表示の簡易処理
* 処理順序の巻き戻し（履歴など）
* `sort()` と併用して昇降順切替

### 注意点

* 破壊的操作で戻り値は `None`
* 辞書順や大小比較とは無関係
* `lst = lst.reverse()` はバグになる

### パフォーマンス

* 計算量：**O(n)**（単純なインプレース反転）

---
# 📢第5章：コピー系メソッド

---

## 📍 `copy()`

### 概要

**リストの浅いコピー**を生成する。元のリストとは別オブジェクトになるが、要素は共有される。

### 使用例

```python
lst = [[1], [2]]
shallow = lst.copy()
shallow[0][0] = 99
# 結果: lst → [[99], [2]] （内部リストは共有）
```

### 想定用途

* 元のリストを保持しながら変更を加えたい場合
* 状態保存（Undo的な処理）
* 処理対象を複製して安全に扱う場合

### 注意点

* **浅いコピー**のため、ネスト構造の内部は共有される
* 完全コピーには `copy.deepcopy()`（標準ライブラリ）が必要

### パフォーマンス

* 計算量：**O(n)**（構造が浅ければ高速）

---

## 📍 `list(iterable)`

### 概要

任意のイテラブルから**新しいリストを生成**する。既にリストでもコピーになる。

### 使用例

```python
original = [1, 2, 3]
copied = list(original)
```

### 想定用途

* ジェネレータやタプルのリスト化
* `copy()` 代替としての利用
* イテラブルを明示的に `list` 化する必要がある場面

### 注意点

* ネスト構造では浅いコピーにとどまる
* 可読性として `copy()` よりも `list()` のほうが明示的でない場合がある

### パフォーマンス

* 計算量：**O(n)**

---
